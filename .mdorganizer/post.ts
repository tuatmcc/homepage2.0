import type { PostTypeBlog, PostTypeNews, PostTypeMember } from './type';
export const allBlog: PostTypeBlog[] = [
  {
    title: 'MCC C言語部内講習会 第2回',
    description: 'MCC C言語部内講習会 第2回 を行いました。',
    date: '2023-05-26',
    tags: ['dev'],
    rootPath: 'content/blog/2023-05-26-mcc-c-lec-2/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\r\n# MCC C言語部内講習会 第2回\r\n\r\n## この講座の対象の人\r\n - MCC部員\r\n - C言語を初歩から学びたい人\r\n\r\n\r\n**この後の内容をチラ見して内容を知っていそうだと判断できる人は次回以降の参加でも大丈夫です！**\r\n\r\n\r\n## ポインタ編\r\n\r\n誰もが苦しむところです。覚悟してください。ポインタをマスターしたら神になれます。はじめはちょっとだけ座学です。\r\n\r\n### メモリ\r\n\r\nここではメモリについてちょっとだけ学びます。ハード的な仕組みは触れません。ソフト的な概念のみです。ハード的な部分はA科の2年後期のASコースの計算機アーキテクチャの授業で習います。\r\n\r\n### bit\r\n\r\nコンピューターでは2進数でデータを扱います。10進数と2進数の変換は高校で習ったと思います。\r\n**bit**(ビット)とは0か1を表す最小単位です。0101は4bit, 111000は6bit, 00110011は8bitです。\r\n\r\n### byte\r\n\r\n基本的なコンピューターでは数値を8bitずつ扱います。8bit集まったものを**1byte**(バイト)と呼びます。\r\n1byteは8bitなので10進数で0～255までの数値を表すことが可能です。\r\nbyte数が大きくなると略したりします。\r\n1024byteで1Kbyte(キロバイト)、1024Kbyteは1Mbyte(メガバイト)、1024Mbyteで1Gbyte(ギガバイト)、1024Gbyteで1Tbyte(テラ)という風に略します。\r\n\r\n|接頭語|記号|byte|\r\n|:--|:-:|--:|\r\n|クエタ quetta|Q|1Qbyte|\r\n|ロナ ronna|R|1Rbyte|\r\n|ヨタ yotta|Y|1Ybyte|\r\n|ゼタ zetta|Z|1Zbyte|\r\n|エクサ exa|E|1Ebyte|\r\n|ペタ peta|P|1Pbyte|\r\n|テラ tera|T|1Tbyte|\r\n|ギガ giga|G|1Gbyte|\r\n|メガ mega|M|1Mbyte|\r\n|キロ kiro|K|1Kbyte|\r\n\r\n### メモリは並んだbyte\r\n\r\nメモリにはbyteが一列に並んでいます。4Gbyteと言われたら、約43億個の1byteが並んでいると考えてください。\r\n先頭から順に1byteずつ番号が振られています。これが**メモリアドレス**です。\r\n\r\n### C言語でメモリアドレスを確認\r\n\r\nC言語で変数のアドレスを確認してみましょう。\r\nアドレスを確認するのにポインタ変数というものを使います。\r\nポインタ変数は変数の前に*(アスタリスク)を付けます。変数のアドレスは変数名の前に&(アンド)をつけることで取得できます。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tint a = 10;\r\n\tint *p = &a;\t// a のアドレスを取得し ポインタ変数 p に代入\r\n\r\n\tprintf("a = %d\\n", a);\r\n\tprintf("Address is : %p\\n", p);\r\n\tprintf("Address decimal number : %u\\n", p);\r\n}\r\n```\r\n\r\nprintfでフォーマット指定子がそれぞれ %d, %p, %u になっていることに注意してください。\r\nフォーマット指定子についてはそのうち触れます。\r\n\r\nコンパイルの警告は無視して大丈夫です。\r\n\r\naの中身とそのアドレスが16進数で表示されたと思います。何回か実行してみましょう。毎回値が変わると思います。\r\n\r\n続いて配列のアドレスを確認します。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tint a[] = {1, 2, 3, 4, 5};\r\n\tint *p = a;\r\n\tint *p0 = &a[0];\r\n\tint *p1 = &a[1];\r\n\tint *p2 = &a[2];\r\n\tint *p3 = &a[3];\r\n\tint *p4 = &a[4];\r\n\r\n\tprintf("a is : %p\\n", p);\r\n\tprintf("a0 is : %p\\n", p0);\r\n\tprintf("a1 is : %p\\n", p1);\r\n\tprintf("a2 is : %p\\n", p2);\r\n\tprintf("a3 is : %p\\n", p3);\r\n\tprintf("a4 is : %p\\n", p4);\r\n}\r\n```\r\n\r\nint *p = a; で &a ではなく a であることに注意してください。\r\n\r\na と a[0] のアドレスが一致することがわかると思います。また、a[0]～a[4]まで、アドレスが4ずつ増えてるのがわかると思います。\r\nこれは a のアドレス自体は a[0] のアドレスを指しており、a[0]～a[4]はメモリ上で32bit(4byte)ずつ連続して存在しているからです。\r\n\r\np に a のアドレスを代入するとき、&が必要ないことから次のようなプログラムが作れることに気がつく人がいると思います。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tint a[] = {1, 2, 3, 4, 5};\r\n\tint *p = a;\r\n\r\n\tfor(int i = 0; i < 5; i++){\r\n\t\tprintf("%d\\n", p[i]);\r\n\t}\r\n}\r\n```\r\n\r\n配列みたいに動作したと思います。\r\nしかし ポインタ=配列 の関係ではありません。勘違いしないでください。\r\n配列は[]演算子でアドレスにインデックス番号の値だけ足して要素にアクセスします。\r\nそのため、似たような使い方でポインタにもできるだけです。\r\n\r\n### Swap関数(参照渡し)\r\n\r\n2つの変数の数値を入れ替えるSwap関数を実装しましょう。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid swap(int a, int b){\r\n\tint tmp = a;\r\n\ta = b;\r\n\tb = tmp;\r\n}\r\n\r\nint main(void)\r\n{\r\n\tint x, y;\r\n\tx = 5;\r\n\ty = 3;\r\n\t\r\n\tprintf("x = %d, y = %d\\n", x, y);\r\n\r\n\tswap(x, y);\r\n\r\n\tprintf("x = %d, y = %d\\n", x, y);\r\n}\r\n```\r\n\r\n入れ替わりません。x,y,a,bのアドレスを確認してみましょう。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid swap(int a, int b){\r\n\tprintf("&a = %p, &b = %p\\n", &a, &b);\r\n\tint tmp = a;\r\n\ta = b;\r\n\tb = tmp;\r\n}\r\n\r\nint main(void)\r\n{\r\n\tint x, y;\r\n\tx = 5;\r\n\ty = 3;\r\n\t\r\n\tprintf("x = %d, y = %d\\n", x, y);\r\n\tprintf("&x = %p, &y = %p\\n", &x, &y);\r\n\r\n\tswap(x, y);\r\n\r\n\tprintf("x = %d, y = %d\\n", x, y);\r\n\tprintf("&x = %p, &y = %p\\n", &x, &y);\r\n}\r\n```\r\n\r\nxとyのアドレスはswap関数を呼び出す前と後で変わらないと思います。aとbのアドレスはxとyのアドレスと異なっていると思います。このことからa,bはx,y自体を触れていないことがわかります。\r\n\r\nswap関数でx,yを直接触るにはx,yの数値をswapに渡すのではなく、x,yのアドレスを渡しましょう。swap関数内で、アドレスから数値を触るには*を変数名の前につけます。アドレスから数値をさわれれば、取得、代入ができます。\r\n\r\nアスタリスクの位置に注意して実装しましょう。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid swap(int *a, int *b){\r\n\tprintf("a = %p, b = %p\\n", a, b);\r\n\tint tmp = *a;\r\n\t*a = *b;\r\n\t*b = tmp;\r\n}\r\n\r\nint main(void)\r\n{\r\n\tint x, y;\r\n\tx = 5;\r\n\ty = 3;\r\n\t\r\n\tprintf("x = %d, y = %d\\n", x, y);\r\n\tprintf("&x = %p, &y = %p\\n", &x, &y);\r\n\r\n\tswap(&x, &y);\r\n\r\n\tprintf("x = %d, y = %d\\n", x, y);\r\n\tprintf("&x = %p, &y = %p\\n", &x, &y);\r\n}\r\n```\r\n\r\nx,yのアドレスを渡すことで2つの変数の数値を入れ替えるSwap関数が完成しました。\r\n\r\n### ポインタ実践\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tint a = 334;\r\n\tint *ap = &a;\r\n\r\n\tprintf("a Address is %p\\n", ap);\r\n\tprintf("a = %d\\n", a);\r\n\r\n\t*ap = 114514;\r\n\r\n\tprintf("a = %d\\n", a);\r\n}\r\n```\r\n\r\nSegmentation fault (core dumped)\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tint a = 334;\r\n\tint *ap = &a;\r\n\r\n\tprintf("a Address is %p\\n", ap);\r\n\tprintf("a = %d\\n", a);\r\n\tprintf("a = %d\\n", *ap);\r\n\r\n\tap = 114514;\r\n\r\n\tprintf("a = %d\\n", a);\r\n\tprintf("a = %d\\n", *ap);\r\n}\r\n```\r\n\r\n\r\n\r\nアドレスの確認を他の型でも確認してみましょう\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tchar c = \'a\';\r\n\tchar ac[] = "abc";\r\n\tchar *cp = &c;\r\n\tchar *acp = ac;\r\n\r\n\tprintf("c = %c\\n", c);\r\n\tprintf("Address is : %p\\n", cp);\r\n\tprintf("Address decimal number : %u\\n", cp);\r\n\r\n\tfor(int i = 0; i < 3; i++){\r\n\t\tprintf("Address char is : %p\\n", &ac[i]);\r\n\t}\r\n\r\n\r\n\r\n\tshort s = 1;\r\n\tshort as[] = {1, 2, 3, 4, 5};\r\n\tshort *sp = &s;\r\n\tshort *asp = as;\r\n\r\n\tprintf("s = %d\\n", s);\r\n\tprintf("Address is : %p\\n", sp);\r\n\tprintf("Address decimal number : %u\\n", sp);\r\n\r\n\tfor(int i = 0; i < 5; i++){\r\n\t\tprintf("Address char is : %p\\n", &as[i]);\r\n\t}\r\n\r\n\r\n\r\n\tlong l = 1;\r\n\tlong al[] = {1, 2, 3, 4, 5};\r\n\tlong *lp = &l;\r\n\tlong *alp = alp;\r\n\r\n\tprintf("l = %d\\n", l);\r\n\tprintf("Address is : %p\\n", lp);\r\n\tprintf("Address decimal number : %u\\n", lp);\r\n\r\n\tfor(int i = 0; i < 5; i++){\r\n\t\tprintf("Address char is : %p\\n", &al[i]);\r\n\t}\r\n}\r\n```\r\n\r\nポインタ変数はインクリメントが使えます。\r\n\r\n\r\n```C\r\n#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n\tint a[] = {1, 2, 3, 4, 5};\r\n\tint *p = a;\r\n\r\n\tfor(int i = 0; i < 5; i++){\r\n\t\tprintf("%d\\n", *p++);\r\n\t}\r\n}\r\n```\r\n\r\n',
    html: '\n<h1 id="user-content-mcc-c言語部内講習会-第2回">MCC C言語部内講習会 第2回</h1>\n<h2 id="user-content-この講座の対象の人">この講座の対象の人</h2>\n<ul>\n  <li>MCC部員</li>\n  <li>C言語を初歩から学びたい人</li>\n</ul>\n<p><strong>この後の内容をチラ見して内容を知っていそうだと判断できる人は次回以降の参加でも大丈夫です！</strong></p>\n<h2 id="user-content-ポインタ編">ポインタ編</h2>\n<p>誰もが苦しむところです。覚悟してください。ポインタをマスターしたら神になれます。はじめはちょっとだけ座学です。</p>\n<h3 id="user-content-メモリ">メモリ</h3>\n<p>ここではメモリについてちょっとだけ学びます。ハード的な仕組みは触れません。ソフト的な概念のみです。ハード的な部分はA科の2年後期のASコースの計算機アーキテクチャの授業で習います。</p>\n<h3 id="user-content-bit">bit</h3>\n<p>\n  コンピューターでは2進数でデータを扱います。10進数と2進数の変換は高校で習ったと思います。\r\n  <strong>bit</strong>(ビット)とは0か1を表す最小単位です。0101は4bit, 111000は6bit, 00110011は8bitです。\n</p>\n<h3 id="user-content-byte">byte</h3>\n<p>\n  基本的なコンピューターでは数値を8bitずつ扱います。8bit集まったものを<strong>1byte</strong>(バイト)と呼びます。\r\n  1byteは8bitなので10進数で0～255までの数値を表すことが可能です。\r\n  byte数が大きくなると略したりします。\r\n  1024byteで1Kbyte(キロバイト)、1024Kbyteは1Mbyte(メガバイト)、1024Mbyteで1Gbyte(ギガバイト)、1024Gbyteで1Tbyte(テラ)という風に略します。\n</p>\n<table>\n  <thead>\n    <tr>\n      <th align="left">接頭語</th>\n      <th align="center">記号</th>\n      <th align="right">byte</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align="left">クエタ quetta</td>\n      <td align="center">Q</td>\n      <td align="right">1Qbyte</td>\n    </tr>\n    <tr>\n      <td align="left">ロナ ronna</td>\n      <td align="center">R</td>\n      <td align="right">1Rbyte</td>\n    </tr>\n    <tr>\n      <td align="left">ヨタ yotta</td>\n      <td align="center">Y</td>\n      <td align="right">1Ybyte</td>\n    </tr>\n    <tr>\n      <td align="left">ゼタ zetta</td>\n      <td align="center">Z</td>\n      <td align="right">1Zbyte</td>\n    </tr>\n    <tr>\n      <td align="left">エクサ exa</td>\n      <td align="center">E</td>\n      <td align="right">1Ebyte</td>\n    </tr>\n    <tr>\n      <td align="left">ペタ peta</td>\n      <td align="center">P</td>\n      <td align="right">1Pbyte</td>\n    </tr>\n    <tr>\n      <td align="left">テラ tera</td>\n      <td align="center">T</td>\n      <td align="right">1Tbyte</td>\n    </tr>\n    <tr>\n      <td align="left">ギガ giga</td>\n      <td align="center">G</td>\n      <td align="right">1Gbyte</td>\n    </tr>\n    <tr>\n      <td align="left">メガ mega</td>\n      <td align="center">M</td>\n      <td align="right">1Mbyte</td>\n    </tr>\n    <tr>\n      <td align="left">キロ kiro</td>\n      <td align="center">K</td>\n      <td align="right">1Kbyte</td>\n    </tr>\n  </tbody>\n</table>\n<h3 id="user-content-メモリは並んだbyte">メモリは並んだbyte</h3>\n<p>\n  メモリにはbyteが一列に並んでいます。4Gbyteと言われたら、約43億個の1byteが並んでいると考えてください。\r\n  先頭から順に1byteずつ番号が振られています。これが<strong>メモリアドレス</strong>です。\n</p>\n<h3 id="user-content-c言語でメモリアドレスを確認">C言語でメモリアドレスを確認</h3>\n<p>\n  C言語で変数のアドレスを確認してみましょう。\r\n  アドレスを確認するのにポインタ変数というものを使います。\r\n  ポインタ変数は変数の前に*(アスタリスク)を付けます。変数のアドレスは変数名の前に&#x26;(アンド)をつけることで取得できます。\n</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> a </span><span>=</span><span> </span><span>10</span><span>;</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p </span><span>=</span><span> </span><span>&#x26;</span><span>a;</span><span>\t// a のアドレスを取得し ポインタ変数 p に代入</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, a);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address is : </span><span>%p\\n</span><span>"</span><span>, p);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address decimal number : </span><span>%u\\n</span><span>"</span><span>, p);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  printfでフォーマット指定子がそれぞれ %d, %p, %u になっていることに注意してください。\r\n  フォーマット指定子についてはそのうち触れます。\n</p>\n<p>コンパイルの警告は無視して大丈夫です。</p>\n<p>aの中身とそのアドレスが16進数で表示されたと思います。何回か実行してみましょう。毎回値が変わると思います。</p>\n<p>続いて配列のアドレスを確認します。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> a</span><span>[]</span><span> </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>};</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p </span><span>=</span><span> a;</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p0 </span><span>=</span><span> </span><span>&#x26;</span><span>a</span><span>[</span><span>0</span><span>];</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p1 </span><span>=</span><span> </span><span>&#x26;</span><span>a</span><span>[</span><span>1</span><span>];</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p2 </span><span>=</span><span> </span><span>&#x26;</span><span>a</span><span>[</span><span>2</span><span>];</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p3 </span><span>=</span><span> </span><span>&#x26;</span><span>a</span><span>[</span><span>3</span><span>];</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p4 </span><span>=</span><span> </span><span>&#x26;</span><span>a</span><span>[</span><span>4</span><span>];</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a is : </span><span>%p\\n</span><span>"</span><span>, p);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a0 is : </span><span>%p\\n</span><span>"</span><span>, p0);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a1 is : </span><span>%p\\n</span><span>"</span><span>, p1);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a2 is : </span><span>%p\\n</span><span>"</span><span>, p2);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a3 is : </span><span>%p\\n</span><span>"</span><span>, p3);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a4 is : </span><span>%p\\n</span><span>"</span><span>, p4);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>int *p = a; で &#x26;a ではなく a であることに注意してください。</p>\n<p>\n  a と a[0] のアドレスが一致することがわかると思います。また、a[0]～a[4]まで、アドレスが4ずつ増えてるのがわかると思います。\r\n  これは a のアドレス自体は a[0] のアドレスを指しており、a[0]～a[4]はメモリ上で32bit(4byte)ずつ連続して存在しているからです。\n</p>\n<p>p に a のアドレスを代入するとき、&#x26;が必要ないことから次のようなプログラムが作れることに気がつく人がいると思います。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> a</span><span>[]</span><span> </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>};</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>p </span><span>=</span><span> a;</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>5</span><span>; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, </span><span>p</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  配列みたいに動作したと思います。\r\n  しかし ポインタ=配列 の関係ではありません。勘違いしないでください。\r\n  配列は[]演算子でアドレスにインデックス番号の値だけ足して要素にアクセスします。\r\n  そのため、似たような使い方でポインタにもできるだけです。\n</p>\n<h3 id="user-content-swap関数参照渡し">Swap関数(参照渡し)</h3>\n<p>2つの変数の数値を入れ替えるSwap関数を実装しましょう。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>void</span><span> </span><span>swap</span><span>(</span><span>int</span><span> </span><span>a</span><span>, </span><span>int</span><span> </span><span>b</span><span>){</span></span>\n<span><span>\t</span><span>int</span><span> tmp </span><span>=</span><span> a;</span></span>\n<span><span>\ta </span><span>=</span><span> b;</span></span>\n<span><span>\tb </span><span>=</span><span> tmp;</span></span>\n<span><span>}</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>\tx </span><span>=</span><span> </span><span>5</span><span>;</span></span>\n<span><span>\ty </span><span>=</span><span> </span><span>3</span><span>;</span></span>\n<span><span>\t</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"x = </span><span>%d</span><span>, y = </span><span>%d\\n</span><span>"</span><span>, x, y);</span></span>\n<span> </span>\n<span><span>\t</span><span>swap</span><span>(x, y);</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"x = </span><span>%d</span><span>, y = </span><span>%d\\n</span><span>"</span><span>, x, y);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>入れ替わりません。x,y,a,bのアドレスを確認してみましょう。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>void</span><span> </span><span>swap</span><span>(</span><span>int</span><span> </span><span>a</span><span>, </span><span>int</span><span> </span><span>b</span><span>){</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"&#x26;a = </span><span>%p</span><span>, &#x26;b = </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>a, </span><span>&#x26;</span><span>b);</span></span>\n<span><span>\t</span><span>int</span><span> tmp </span><span>=</span><span> a;</span></span>\n<span><span>\ta </span><span>=</span><span> b;</span></span>\n<span><span>\tb </span><span>=</span><span> tmp;</span></span>\n<span><span>}</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>\tx </span><span>=</span><span> </span><span>5</span><span>;</span></span>\n<span><span>\ty </span><span>=</span><span> </span><span>3</span><span>;</span></span>\n<span><span>\t</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"x = </span><span>%d</span><span>, y = </span><span>%d\\n</span><span>"</span><span>, x, y);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"&#x26;x = </span><span>%p</span><span>, &#x26;y = </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>x, </span><span>&#x26;</span><span>y);</span></span>\n<span> </span>\n<span><span>\t</span><span>swap</span><span>(x, y);</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"x = </span><span>%d</span><span>, y = </span><span>%d\\n</span><span>"</span><span>, x, y);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"&#x26;x = </span><span>%p</span><span>, &#x26;y = </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>x, </span><span>&#x26;</span><span>y);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>xとyのアドレスはswap関数を呼び出す前と後で変わらないと思います。aとbのアドレスはxとyのアドレスと異なっていると思います。このことからa,bはx,y自体を触れていないことがわかります。</p>\n<p>swap関数でx,yを直接触るにはx,yの数値をswapに渡すのではなく、x,yのアドレスを渡しましょう。swap関数内で、アドレスから数値を触るには*を変数名の前につけます。アドレスから数値をさわれれば、取得、代入ができます。</p>\n<p>アスタリスクの位置に注意して実装しましょう。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>void</span><span> </span><span>swap</span><span>(</span><span>int</span><span> </span><span>*</span><span>a</span><span>, </span><span>int</span><span> </span><span>*</span><span>b</span><span>){</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%p</span><span>, b = </span><span>%p\\n</span><span>"</span><span>, a, b);</span></span>\n<span><span>\t</span><span>int</span><span> tmp </span><span>=</span><span> </span><span>*</span><span>a;</span></span>\n<span><span>\t</span><span>*</span><span>a </span><span>=</span><span> </span><span>*</span><span>b;</span></span>\n<span><span>\t</span><span>*</span><span>b </span><span>=</span><span> tmp;</span></span>\n<span><span>}</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>\tx </span><span>=</span><span> </span><span>5</span><span>;</span></span>\n<span><span>\ty </span><span>=</span><span> </span><span>3</span><span>;</span></span>\n<span><span>\t</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"x = </span><span>%d</span><span>, y = </span><span>%d\\n</span><span>"</span><span>, x, y);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"&#x26;x = </span><span>%p</span><span>, &#x26;y = </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>x, </span><span>&#x26;</span><span>y);</span></span>\n<span> </span>\n<span><span>\t</span><span>swap</span><span>(</span><span>&#x26;</span><span>x, </span><span>&#x26;</span><span>y);</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"x = </span><span>%d</span><span>, y = </span><span>%d\\n</span><span>"</span><span>, x, y);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"&#x26;x = </span><span>%p</span><span>, &#x26;y = </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>x, </span><span>&#x26;</span><span>y);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>x,yのアドレスを渡すことで2つの変数の数値を入れ替えるSwap関数が完成しました。</p>\n<h3 id="user-content-ポインタ実践">ポインタ実践</h3>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> a </span><span>=</span><span> </span><span>334</span><span>;</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>ap </span><span>=</span><span> </span><span>&#x26;</span><span>a;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a Address is </span><span>%p\\n</span><span>"</span><span>, ap);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, a);</span></span>\n<span> </span>\n<span><span>\t</span><span>*</span><span>ap </span><span>=</span><span> </span><span>114514</span><span>;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, a);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>Segmentation fault (core dumped)</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>int</span><span> a </span><span>=</span><span> </span><span>334</span><span>;</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>ap </span><span>=</span><span> </span><span>&#x26;</span><span>a;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a Address is </span><span>%p\\n</span><span>"</span><span>, ap);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, a);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, </span><span>*</span><span>ap);</span></span>\n<span> </span>\n<span><span>\tap </span><span>=</span><span> </span><span>114514</span><span>;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, a);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%d\\n</span><span>"</span><span>, </span><span>*</span><span>ap);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>アドレスの確認を他の型でも確認してみましょう</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span></span>\n<span><span>{</span></span>\n<span><span>\t</span><span>char</span><span> c </span><span>=</span><span> </span><span>\'a\'</span><span>;</span></span>\n<span><span>\t</span><span>char</span><span> ac</span><span>[]</span><span> </span><span>=</span><span> </span><span>"abc"</span><span>;</span></span>\n<span><span>\t</span><span>char</span><span> </span><span>*</span><span>cp </span><span>=</span><span> </span><span>&#x26;</span><span>c;</span></span>\n<span><span>\t</span><span>char</span><span> </span><span>*</span><span>acp </span><span>=</span><span> ac;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"c = </span><span>%c\\n</span><span>"</span><span>, c);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address is : </span><span>%p\\n</span><span>"</span><span>, cp);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address decimal number : </span><span>%u\\n</span><span>"</span><span>, cp);</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>3</span><span>; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"Address char is : </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>ac</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span> </span>\n<span> </span>\n<span> </span>\n<span><span>\t</span><span>short</span><span> s </span><span>=</span><span> </span><span>1</span><span>;</span></span>\n<span><span>\t</span><span>short</span><span> as</span><span>[]</span><span> </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>};</span></span>\n<span><span>\t</span><span>short</span><span> </span><span>*</span><span>sp </span><span>=</span><span> </span><span>&#x26;</span><span>s;</span></span>\n<span><span>\t</span><span>short</span><span> </span><span>*</span><span>asp </span><span>=</span><span> as;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"s = </span><span>%d\\n</span><span>"</span><span>, s);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address is : </span><span>%p\\n</span><span>"</span><span>, sp);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address decimal number : </span><span>%u\\n</span><span>"</span><span>, sp);</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>5</span><span>; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"Address char is : </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>as</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span> </span>\n<span> </span>\n<span> </span>\n<span><span>\t</span><span>long</span><span> l </span><span>=</span><span> </span><span>1</span><span>;</span></span>\n<span><span>\t</span><span>long</span><span> al</span><span>[]</span><span> </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>};</span></span>\n<span><span>\t</span><span>long</span><span> </span><span>*</span><span>lp </span><span>=</span><span> </span><span>&#x26;</span><span>l;</span></span>\n<span><span>\t</span><span>long</span><span> </span><span>*</span><span>alp </span><span>=</span><span> alp;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"l = </span><span>%d\\n</span><span>"</span><span>, l);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address is : </span><span>%p\\n</span><span>"</span><span>, lp);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Address decimal number : </span><span>%u\\n</span><span>"</span><span>, lp);</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>5</span><span>; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"Address char is : </span><span>%p\\n</span><span>"</span><span>, </span><span>&#x26;</span><span>al</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>ポインタ変数はインクリメントが使えます。</p>\n<div>\n  <pre><code><span><span>#include &#x3C;stdio.h></span></span>\n<span><span></span></span>\n<span><span>int main(void)</span></span>\n<span><span>{</span></span>\n<span><span>\tint a[] = {1, 2, 3, 4, 5};</span></span>\n<span><span>\tint *p = a;</span></span>\n<span><span></span></span>\n<span><span>\tfor(int i = 0; i &#x3C; 5; i++){</span></span>\n<span><span>\t\tprintf("%d\\n", *p++);</span></span>\n<span><span>\t}</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n',
  },
  {
    title: 'MCC C言語部内講習会 第3回',
    description: 'MCC C言語部内講習会 第3回 を行いました。',
    date: '2023-05-26',
    tags: ['dev'],
    rootPath: 'content/blog/2023-05-26-mcc-c-lec-3/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\r\n# MCC C言語部内講習会 第3回\r\n\r\n## この講座の対象の人\r\n - MCC部員\r\n - C言語を初歩から学びたい人\r\n\r\n\r\n**この後の内容をチラ見して内容を知っていそうだと判断できる人は次回以降の参加でも大丈夫です！**\r\n\r\n## キャスト\r\n\r\nキャストとは型変換です。以下に`double`, `float`, `int`, `long`のキャストの例を示します。\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\tdouble a = 1.5;\r\n\tfloat b = (float) a;\r\n\tint c = (int) b;\r\n\tlong d = (long) c;\r\n\r\n\tprintf("a = %lf\\n", a);\r\n\tprintf("b = %f\\n", b);\r\n\tprintf("c = %d\\n", c);\r\n\tprintf("d = %ld\\n", d);\r\n}\r\n```\r\n```\r\na = 1.500000\r\nb = 1.500000\r\nc = 1\r\nd = 1\r\n```\r\n少数型を整数型にキャストしたら切り捨てされます。一部型では省略できます。\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\tdouble a = 1.5;\r\n\tfloat b = a;\r\n\tint c = b;\r\n\tlong d = c;\r\n\r\n\tprintf("a = %lf\\n", a);\r\n\tprintf("b = %f\\n", b);\r\n\tprintf("c = %d\\n", c);\r\n\tprintf("d = %ld\\n", d);\r\n}\r\n```\r\n\r\n## 動的配列\r\n今回は動的配列について学びます。その前に、配列についてちょっとだけ復習をしておこうと思います。\r\n\r\n### 配列\r\n配列とは、**同じ型**のデータを連続に並べたものです。\r\n今まで学んだ配列変数の定義の仕方として、次のようなものがありました。\r\n```c\r\nint main() {\r\n\tint arr[3] = {1, 2, 3};\r\n}\r\n```\r\n\r\n![配列イメージ](1.png "配列イメージ")\r\n\r\nこのように配列を定義した場合、上の例における `arr` の長さ（サイズ）は `3` (4 × 3 = 12byte)で固定されており、範囲外は他のプロセスが使用しているため、後から伸長することは不可能です。\r\n\r\n### 動的メモリ確保(malloc)\r\n配列の長さ10個だけ必要なとき、100個だけ必要なとき、1000個だけ必要なとき...があると思います。予め1000個の長さの配列を作っても、10個だけしか使わなければ9990個は無駄になります。このような場面には、`malloc` 関数を用いて**動的**にメモリを確保します。`malloc`関数は引数で指定した分、メモリを確保し、確保したメモリのアドレスを返します。`malloc` 関数はヘッダファイル `stdlib.h` に定義されています。次に `malloc` 関数の使用例を示します。`#include <stdlib.h>`を忘れないでください。\r\n```c\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\tint *arr = (int *)malloc(sizeof(int)*3);\r\n}\r\n```\r\n![malloc関数](2.png "malloc関数")\r\n上の例において、`int*` 型の変数 `arr` はint `3` 要素分のメモリを持っています。`sizeof`はsizeof演算子と言い、データ型の大きさを求める演算子です。ここではintの大きさを求めています。以下に型のサイズの例を示します。`arr` の長さ（サイズ）は `3` (4 × 3 = 12byte)で要素数3のint型配列と同じように扱えます。`malloc`関数は乱用ポインタ(`void*`)を返すので`int*`にキャスト(型変換)してください。\r\n\r\n|type|ex.|result|\r\n|--|--|:--:|\r\n|char|sizeof(char)|1|\r\n|short|sizeof(short)|2|\r\n|int|sizeof(int)|4|\r\n|long|sizeof(long)|8|\r\n\r\n次のようにして、ユーザーの入力分だけのメモリを確保することも可能です。コンソールで10と入力すればnに10が入り、arrは要素数10のint型配列になります。\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\tint n;\t\t// 配列の要素数\r\n\tint *arr;\t// 動的配列を割り当てるためのポインタ変数\r\n\r\n\tscanf("%d", &n); // ユーザーからの入力を受け取る\r\n\tarr = (int *)malloc(sizeof(int) * n);\r\n\r\n\tfor(int i = 0; i < n; i++){\r\n\t\tarr[i] = i;\r\n\t}\r\n\r\n\tfor(int i = 0; i < n; i++){\r\n\t\tprintf("%d\\n", arr[i]);\r\n\t}\r\n}\r\n```\r\nさて、ここで `malloc` 関数について詳しく説明したいと思います。  \r\nこの関数の引数は、`size_t(unsigned int)` 型の、確保するメモリの Byte 数です。注意点として、C言語では型によってメモリのサイズが異なるため、異なる型を一つの配列に入れられないという点があります。具体例を次に示します。\r\n\r\n![乱型配列](3.png "乱型配列")\r\n\r\nまた、変数のサイズを忘れ、以下の誤りをよく発生します。注意してください。\r\n\r\n```c\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\tint *arr = (int *)malloc(3); // int型3要素の配列を定義しようとした\r\n\t// int *arr = (int *)malloc(sizeof(int) * 3); 正しくはこう\r\n\tarr[0] = 12;\r\n\tarr[1] = 34;\r\n\tarr[2] = 56;\r\n\t// このデモでは発生しないが、意図しないメモリの値を書き換えてしまっている！\r\n}\r\n```\r\n![サイズ忘れ](4.png "サイズ忘れ")\r\n\r\n次に、返り値について説明します。`malloc` の返り値は、`void *` 型で、確保されたメモリの先頭のポインタで、何かしらのポインタを意味します。このポインタのアドレスを基準に、配列の内容にアクセスします。アクセスの方法は普通の配列と同様にできます。`void *`も`int *`も中身はアドレス(整数)であるため、キャストができ省略もできます。`void *`は`float *`にも`double *`にもキャストできます。`int*`だったらインクリメントしただけでアドレスが+4されたりします(配列で便利)。(`short*`だったら+2、`char*`だったら+1)\r\n\r\n![mallocの戻り値](5.png "mallocの戻り値")\r\n\r\n### 動的に確保したメモリの開放\r\nさて、前項では述べませんでしたが、このように動的に確保したメモリ領域はプログラマが使い終わったタイミングで解放する処理も記述する必要があります。不要なメモリを開放して挙げないと、コンピューターのメモリを使い切ってしまいます。メモリを確保して不要になっても,\r\n確保されたままだからです。不要なメモリを解放するために、`free` 関数を使います。利用方法としては、確保したポインタを `free` 関数に渡すことで実行することができます。次に例を示します。\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\tint *arr = (int *)malloc(sizeof(int) * 3);\t// メモリ確保\r\n\tarr[0] = 12;\r\n\tarr[1] = 34;\r\n\tarr[2] = 56;\r\n\tfor (int i = 0; i < 3; ++i) {\r\n\t\tprintf("%d\\n", arr[i]);\r\n\t}\r\n\tfree(arr);\t// メモリ解放\r\n}\r\n```\r\n\r\nこのようにして、動的に確保したメモリ領域を解放することができます。  \r\n注意点として、一度解放したメモリ領域をもう一度解放しようとするとエラーが発生します。\r\n```c\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\tint *arr = (int *)malloc(sizeof(int) * 3);\r\n\tfree(arr);\r\n\tfree(arr);\t// 実行時にエラー発生\r\n}\r\n```\r\n\r\n```\r\nfree(): double free detected in tcache 2\r\nAborted (core dumped)\r\n```\r\n\r\nまた、一度解放したメモリ領域を参照しようとしてはいけません。メモリの内容が破壊される可能性があります。\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n\tint *arr = (int *)malloc(sizeof(int) * 3);\r\n\tarr[0] = 12;\r\n\tarr[1] = 34;\r\n\tarr[2] = 56;\r\n\tfree(arr);\r\n\t// ↑で解放済みなのに↓で参照してしまった！\r\n\tprintf("%d\\n", arr[0]);\r\n\t// 佐藤の手元の環境では 0 が表示された\r\n}\r\n```\r\n\r\nfreeし忘れても、基本的にプロセスが終了(プログラムが実行終了)すればメモリは勝手に開放されます。しかし、常時稼働のプログラム(サーバーなど)を作るときに、メモリ解放することを忘れないようにするため、freeすることを心がけてください。\r\n\r\n---\r\n\r\n## 構造体\r\n次に、構造体を紹介します。\r\n構造体とは、異なる型のいくつかの情報をまとめて一つの型として管理するためのものです。変数の箱の中に変数の箱が入っているイメージです。例を見てみましょう。\r\n```c\r\nstruct Point2D {\r\n\tint x, y;\r\n};\r\n```\r\n上の例では、`int` 型のメンバ変数 `x`, `y` を持つ `Point2D` という構造体を**定義**しています。  \r\n実際に `Point2D` 型の変数を宣言する際には次のように行います。\r\n```c\r\nstruct Point2D {\r\n\tint x, y;\r\n};\r\n\r\nint main() {\r\n\tstruct Point2D p;\r\n}\r\n```\r\nまた、`Point2D` の持つ メンバ変数`x`, `y` には次のように`.`でアクセスすることができます。\r\n```c\r\n#include <stdio.h>\r\n\r\nstruct Point2D {\r\n\tint x, y;\r\n};\r\n\r\nint main() {\r\n\tstruct Point2D p;\r\n\tp.x = 1;\r\n\tp.y = 2;\r\n\tprintf("p.x=%d, p.y=%d\\n", p.x, p.y);\r\n}\r\n```\r\n\r\n![構造体](6.png "構造体")\r\n\r\n![構造体](7.png "構造体") \r\n  \r\n構造体を型として宣言(type definition)することで省略できます。下記の`typedef struct Point2D P2D;`は「`struct Point2D`を`P2D`とします。」という意味です。P2Dはタグと言います。\r\n```c\r\nstruct Point2D {\r\n\tint x, y;\r\n};\r\ntypedef struct Point2D P2D;\r\n\r\nint main(){\r\n\tP2D p2;\r\n}\r\n```\r\n構造体の宣言とその構造体を型として宣言することを同時に行うこともできます。\r\n```c\r\ntypedef struct Point3D {\r\n\tint x, y, z;\r\n} P3D;\r\n\r\nint main(){\r\n\tP3D p3;\r\n}\r\n```\r\n構造体のタグ名と型名に全く同じ名前を付けることもできます。\r\n```c\r\ntypedef struct Vec2D {\r\n\tint x, y;\r\n} Vec2D;\r\n\r\nint main(){\r\n\tVec2D v2;\r\n}\r\n```\r\n構造体が他の構造体をメンバに持つことも可能です。\r\n```c\r\ntypedef struct Point2D {\r\n\tint x, y;\r\n} P2D;\r\n\r\ntypedef struct Line2D {\r\n\tP2D from, to;\r\n} Line2D;\r\n\r\nint main(){\r\n\tLine2D l2;\r\n\r\n\tl2.from.x = 0;\r\n\tl2.from.y = 0;\r\n\r\n\tl2.to.x = 1;\r\n\tl2.to.y = 1;\r\n}\r\n```\r\n\r\n構造体のポインタ変数を宣言することも可能です。  \r\n構造体のポインタ変数からメンバ変数にアクセスする際には->(アロー)演算子を使います。-(ハイフン)と>(大なり)です。\r\n```c\r\n#include <stdio.h>\r\n\r\ntypedef struct Point2D {\r\n\tint x, y;\r\n} Point2D;\r\n\r\nint main() {\r\n\tPoint2D p;\r\n\tPoint2D *poi;\r\n\t\r\n\tp.x = 12;\r\n\tp.y = 34;\r\n\r\n\tprintf("p.x=%d, p.y=%d\\n", p.x, p.y);\r\n\tpoi = &p;\r\n\t\r\n\t// 構造体のポインタ変数からのメンバアクセスには\r\n\t// -> 演算子を使う\r\n\tprintf("poi->x=%d, poi->y=%d\\n", poi->x, poi->y);\r\n\r\n\t// これと同じ\r\n\tprintf("poi->x=%d, poi->y=%d\\n", (*poi).x, (*poi).y);\r\n}\r\n```\r\n\r\n構造体のメモリを動的に確保することも可能です。ちなみに`Point2D`は`int`型の変数が2つあるので`sizeof(Point2D)`は`8`を返します。\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef struct Point2D {\r\n\tint x, y;\r\n} Point2D;\r\n\r\n\r\nint main() {\r\n\tPoint2D *p = (Point2D *)malloc(sizeof(Point2D) * 1);\r\n\t(*p).x = 12;\r\n\tprintf("%d\\n", (*p).x);\r\n\tp->x = 34;\r\n\tprintf("%d\\n", p->x);\r\n\tfree(p);\r\n}\r\n```\r\n\r\n構造体の配列も動的に生成できます。\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ntypedef struct Point2D {\r\n\tint x, y;\r\n} Point2D;\r\n\r\n\r\nint main() {\r\n\tint length;\r\n\r\n\tprintf("Input lenght: ");\r\n\tscanf("%d", &length);\r\n\r\n\tPoint2D *p = (Point2D *)malloc(sizeof(Point2D) * length);\r\n\t\r\n\tfor (int i = 0; i < length; i++){\r\n\t\tp[i].x = i;\r\n\t\tp[i].y = 2 * i;\r\n\t}\r\n\r\n\tfor (int i = 0; i < length; i++){\r\n\t\tprintf("p[%d].x = %d, p[%d].y = %d\\n", i, p[i].x, i, p[i].y);\r\n\t}\r\n\r\n\tfree(p);\r\n}\r\n```\r\n```\r\nInput lenght: 10\r\np[0].x = 0, p[0].y = 0\r\np[1].x = 1, p[1].y = 2\r\np[2].x = 2, p[2].y = 4\r\np[3].x = 3, p[3].y = 6\r\np[4].x = 4, p[4].y = 8\r\np[5].x = 5, p[5].y = 10\r\np[6].x = 6, p[6].y = 12\r\np[7].x = 7, p[7].y = 14\r\np[8].x = 8, p[8].y = 16\r\np[9].x = 9, p[9].y = 18\r\n```\r\n```\r\nInput lenght: 5\r\np[0].x = 0, p[0].y = 0\r\np[1].x = 1, p[1].y = 2\r\np[2].x = 2, p[2].y = 4\r\np[3].x = 3, p[3].y = 6\r\np[4].x = 4, p[4].y = 8\r\n```\r\n',
    html: '\n<h1 id="user-content-mcc-c言語部内講習会-第3回">MCC C言語部内講習会 第3回</h1>\n<h2 id="user-content-この講座の対象の人">この講座の対象の人</h2>\n<ul>\n  <li>MCC部員</li>\n  <li>C言語を初歩から学びたい人</li>\n</ul>\n<p><strong>この後の内容をチラ見して内容を知っていそうだと判断できる人は次回以降の参加でも大丈夫です！</strong></p>\n<h2 id="user-content-キャスト">キャスト</h2>\n<p>キャストとは型変換です。以下に<code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>のキャストの例を示します。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>double</span><span> a </span><span>=</span><span> </span><span>1.5</span><span>;</span></span>\n<span><span>\t</span><span>float</span><span> b </span><span>=</span><span> (</span><span>float</span><span>) a;</span></span>\n<span><span>\t</span><span>int</span><span> c </span><span>=</span><span> (</span><span>int</span><span>) b;</span></span>\n<span><span>\t</span><span>long</span><span> d </span><span>=</span><span> (</span><span>long</span><span>) c;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%lf\\n</span><span>"</span><span>, a);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"b = </span><span>%f\\n</span><span>"</span><span>, b);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"c = </span><span>%d\\n</span><span>"</span><span>, c);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"d = </span><span>%ld\\n</span><span>"</span><span>, d);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<pre><code>a = 1.500000\r\nb = 1.500000\r\nc = 1\r\nd = 1\n</code></pre>\n<p>少数型を整数型にキャストしたら切り捨てされます。一部型では省略できます。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>double</span><span> a </span><span>=</span><span> </span><span>1.5</span><span>;</span></span>\n<span><span>\t</span><span>float</span><span> b </span><span>=</span><span> a;</span></span>\n<span><span>\t</span><span>int</span><span> c </span><span>=</span><span> b;</span></span>\n<span><span>\t</span><span>long</span><span> d </span><span>=</span><span> c;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"a = </span><span>%lf\\n</span><span>"</span><span>, a);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"b = </span><span>%f\\n</span><span>"</span><span>, b);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"c = </span><span>%d\\n</span><span>"</span><span>, c);</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"d = </span><span>%ld\\n</span><span>"</span><span>, d);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<h2 id="user-content-動的配列">動的配列</h2>\n<p>今回は動的配列について学びます。その前に、配列についてちょっとだけ復習をしておこうと思います。</p>\n<h3 id="user-content-配列">配列</h3>\n<p>\n  配列とは、<strong>同じ型</strong>のデータを連続に並べたものです。\r\n  今まで学んだ配列変数の定義の仕方として、次のようなものがありました。\n</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>arr</span><span>[</span><span>3</span><span>] </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>};</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  <img src="1.png" alt="配列イメージ" title="配列イメージ">\n</p>\n<p>このように配列を定義した場合、上の例における <code>arr</code> の長さ（サイズ）は <code>3</code> (4 × 3 = 12byte)で固定されており、範囲外は他のプロセスが使用しているため、後から伸長することは不可能です。</p>\n<h3 id="user-content-動的メモリ確保malloc">動的メモリ確保(malloc)</h3>\n<p>配列の長さ10個だけ必要なとき、100個だけ必要なとき、1000個だけ必要なとき...があると思います。予め1000個の長さの配列を作っても、10個だけしか使わなければ9990個は無駄になります。このような場面には、<code>malloc</code> 関数を用いて<strong>動的</strong>にメモリを確保します。<code>malloc</code>関数は引数で指定した分、メモリを確保し、確保したメモリのアドレスを返します。<code>malloc</code> 関数はヘッダファイル <code>stdlib.h</code> に定義されています。次に <code>malloc</code> 関数の使用例を示します。<code>#include &#x3C;stdlib.h></code>を忘れないでください。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>arr </span><span>=</span><span> (</span><span>int</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>)</span><span>*</span><span>3</span><span>);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  <img src="2.png" alt="malloc関数" title="malloc関数">\r\n  上の例において、<code>int*</code> 型の変数 <code>arr</code> はint <code>3</code> 要素分のメモリを持っています。<code>sizeof</code>はsizeof演算子と言い、データ型の大きさを求める演算子です。ここではintの大きさを求めています。以下に型のサイズの例を示します。<code>arr</code> の長さ（サイズ）は <code>3</code> (4 × 3 = 12byte)で要素数3のint型配列と同じように扱えます。<code>malloc</code>関数は乱用ポインタ(<code>void*</code>)を返すので<code>int*</code>にキャスト(型変換)してください。\n</p>\n<table>\n  <thead>\n    <tr>\n      <th>type</th>\n      <th>ex.</th>\n      <th align="center">result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>char</td>\n      <td>sizeof(char)</td>\n      <td align="center">1</td>\n    </tr>\n    <tr>\n      <td>short</td>\n      <td>sizeof(short)</td>\n      <td align="center">2</td>\n    </tr>\n    <tr>\n      <td>int</td>\n      <td>sizeof(int)</td>\n      <td align="center">4</td>\n    </tr>\n    <tr>\n      <td>long</td>\n      <td>sizeof(long)</td>\n      <td align="center">8</td>\n    </tr>\n  </tbody>\n</table>\n<p>次のようにして、ユーザーの入力分だけのメモリを確保することも可能です。コンソールで10と入力すればnに10が入り、arrは要素数10のint型配列になります。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> n;</span><span>\t\t// 配列の要素数</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>arr;</span><span>\t// 動的配列を割り当てるためのポインタ変数</span></span>\n<span> </span>\n<span><span>\t</span><span>scanf</span><span>(</span><span>"</span><span>%d</span><span>"</span><span>, </span><span>&#x26;</span><span>n);</span><span> // ユーザーからの入力を受け取る</span></span>\n<span><span>\tarr </span><span>=</span><span> (</span><span>int</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>) </span><span>*</span><span> n);</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> n; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>arr</span><span>[i] </span><span>=</span><span> i;</span></span>\n<span><span>\t}</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> n; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, </span><span>arr</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>さて、ここで <code>malloc</code> 関数について詳しく説明したいと思います。<br>この関数の引数は、<code>size_t(unsigned int)</code> 型の、確保するメモリの Byte 数です。注意点として、C言語では型によってメモリのサイズが異なるため、異なる型を一つの配列に入れられないという点があります。具体例を次に示します。</p>\n<p>\n  <img src="3.png" alt="乱型配列" title="乱型配列">\n</p>\n<p>また、変数のサイズを忘れ、以下の誤りをよく発生します。注意してください。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>arr </span><span>=</span><span> (</span><span>int</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>3</span><span>);</span><span> // int型3要素の配列を定義しようとした</span></span>\n<span><span>\t</span><span>// int *arr = (int *)malloc(sizeof(int) * 3); 正しくはこう</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>0</span><span>] </span><span>=</span><span> </span><span>12</span><span>;</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>1</span><span>] </span><span>=</span><span> </span><span>34</span><span>;</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>2</span><span>] </span><span>=</span><span> </span><span>56</span><span>;</span></span>\n<span><span>\t</span><span>// このデモでは発生しないが、意図しないメモリの値を書き換えてしまっている！</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  <img src="4.png" alt="サイズ忘れ" title="サイズ忘れ">\n</p>\n<p>次に、返り値について説明します。<code>malloc</code> の返り値は、<code>void *</code> 型で、確保されたメモリの先頭のポインタで、何かしらのポインタを意味します。このポインタのアドレスを基準に、配列の内容にアクセスします。アクセスの方法は普通の配列と同様にできます。<code>void *</code>も<code>int *</code>も中身はアドレス(整数)であるため、キャストができ省略もできます。<code>void *</code>は<code>float *</code>にも<code>double *</code>にもキャストできます。<code>int*</code>だったらインクリメントしただけでアドレスが+4されたりします(配列で便利)。(<code>short*</code>だったら+2、<code>char*</code>だったら+1)</p>\n<p>\n  <img src="5.png" alt="mallocの戻り値" title="mallocの戻り値">\n</p>\n<h3 id="user-content-動的に確保したメモリの開放">動的に確保したメモリの開放</h3>\n<p>\n  さて、前項では述べませんでしたが、このように動的に確保したメモリ領域はプログラマが使い終わったタイミングで解放する処理も記述する必要があります。不要なメモリを開放して挙げないと、コンピューターのメモリを使い切ってしまいます。メモリを確保して不要になっても,\r\n  確保されたままだからです。不要なメモリを解放するために、<code>free</code> 関数を使います。利用方法としては、確保したポインタを <code>free</code> 関数に渡すことで実行することができます。次に例を示します。\n</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>arr </span><span>=</span><span> (</span><span>int</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>) </span><span>*</span><span> </span><span>3</span><span>);</span><span>\t// メモリ確保</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>0</span><span>] </span><span>=</span><span> </span><span>12</span><span>;</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>1</span><span>] </span><span>=</span><span> </span><span>34</span><span>;</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>2</span><span>] </span><span>=</span><span> </span><span>56</span><span>;</span></span>\n<span><span>\t</span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>3</span><span>; </span><span>++</span><span>i) {</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, </span><span>arr</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span><span>\t</span><span>free</span><span>(arr);</span><span>\t// メモリ解放</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>このようにして、動的に確保したメモリ領域を解放することができます。<br>注意点として、一度解放したメモリ領域をもう一度解放しようとするとエラーが発生します。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>arr </span><span>=</span><span> (</span><span>int</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>) </span><span>*</span><span> </span><span>3</span><span>);</span></span>\n<span><span>\t</span><span>free</span><span>(arr);</span></span>\n<span><span>\t</span><span>free</span><span>(arr);</span><span>\t// 実行時にエラー発生</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<pre><code>free(): double free detected in tcache 2\r\nAborted (core dumped)\n</code></pre>\n<p>また、一度解放したメモリ領域を参照しようとしてはいけません。メモリの内容が破壊される可能性があります。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>*</span><span>arr </span><span>=</span><span> (</span><span>int</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>) </span><span>*</span><span> </span><span>3</span><span>);</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>0</span><span>] </span><span>=</span><span> </span><span>12</span><span>;</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>1</span><span>] </span><span>=</span><span> </span><span>34</span><span>;</span></span>\n<span><span>\t</span><span>arr</span><span>[</span><span>2</span><span>] </span><span>=</span><span> </span><span>56</span><span>;</span></span>\n<span><span>\t</span><span>free</span><span>(arr);</span></span>\n<span><span>\t</span><span>// ↑で解放済みなのに↓で参照してしまった！</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, </span><span>arr</span><span>[</span><span>0</span><span>]);</span></span>\n<span><span>\t</span><span>// 佐藤の手元の環境では 0 が表示された</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>freeし忘れても、基本的にプロセスが終了(プログラムが実行終了)すればメモリは勝手に開放されます。しかし、常時稼働のプログラム(サーバーなど)を作るときに、メモリ解放することを忘れないようにするため、freeすることを心がけてください。</p>\n<hr>\n<h2 id="user-content-構造体">構造体</h2>\n<p>\n  次に、構造体を紹介します。\r\n  構造体とは、異なる型のいくつかの情報をまとめて一つの型として管理するためのものです。変数の箱の中に変数の箱が入っているイメージです。例を見てみましょう。\n</p>\n<div>\n  <pre><code><span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>};</span></span></code></pre>\n</div>\n<p>上の例では、<code>int</code> 型のメンバ変数 <code>x</code>, <code>y</code> を持つ <code>Point2D</code> という構造体を<strong>定義</strong>しています。<br>実際に <code>Point2D</code> 型の変数を宣言する際には次のように行います。</p>\n<div>\n  <pre><code><span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>};</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>struct</span><span> Point2D p;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>また、<code>Point2D</code> の持つ メンバ変数<code>x</code>, <code>y</code> には次のように<code>.</code>でアクセスすることができます。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>};</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>struct</span><span> Point2D p;</span></span>\n<span><span>\tp.x </span><span>=</span><span> </span><span>1</span><span>;</span></span>\n<span><span>\tp.y </span><span>=</span><span> </span><span>2</span><span>;</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"p.x=</span><span>%d</span><span>, p.y=</span><span>%d\\n</span><span>"</span><span>, p.x, p.y);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  <img src="6.png" alt="構造体" title="構造体">\n</p>\n<p>\n  <img src="7.png" alt="構造体" title="構造体">\n</p>\n<p>構造体を型として宣言(type definition)することで省略できます。下記の<code>typedef struct Point2D P2D;</code>は「<code>struct Point2D</code>を<code>P2D</code>とします。」という意味です。P2Dはタグと言います。</p>\n<div>\n  <pre><code><span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>};</span></span>\n<span><span>typedef</span><span> </span><span>struct</span><span> Point2D P2D;</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(){</span></span>\n<span><span>\tP2D p2;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>構造体の宣言とその構造体を型として宣言することを同時に行うこともできます。</p>\n<div>\n  <pre><code><span><span>typedef</span><span> </span><span>struct</span><span> Point3D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y, z;</span></span>\n<span><span>} P3D;</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(){</span></span>\n<span><span>\tP3D p3;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>構造体のタグ名と型名に全く同じ名前を付けることもできます。</p>\n<div>\n  <pre><code><span><span>typedef</span><span> </span><span>struct</span><span> Vec2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>} Vec2D;</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(){</span></span>\n<span><span>\tVec2D v2;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>構造体が他の構造体をメンバに持つことも可能です。</p>\n<div>\n  <pre><code><span><span>typedef</span><span> </span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>} P2D;</span></span>\n<span> </span>\n<span><span>typedef</span><span> </span><span>struct</span><span> Line2D {</span></span>\n<span><span>\tP2D from, to;</span></span>\n<span><span>} Line2D;</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>(){</span></span>\n<span><span>\tLine2D l2;</span></span>\n<span> </span>\n<span><span>\tl2.from.x </span><span>=</span><span> </span><span>0</span><span>;</span></span>\n<span><span>\tl2.from.y </span><span>=</span><span> </span><span>0</span><span>;</span></span>\n<span> </span>\n<span><span>\tl2.to.x </span><span>=</span><span> </span><span>1</span><span>;</span></span>\n<span><span>\tl2.to.y </span><span>=</span><span> </span><span>1</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>構造体のポインタ変数を宣言することも可能です。<br>構造体のポインタ変数からメンバ変数にアクセスする際には->(アロー)演算子を使います。-(ハイフン)と>(大なり)です。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>typedef</span><span> </span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>} Point2D;</span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\tPoint2D p;</span></span>\n<span><span>\tPoint2D </span><span>*</span><span>poi;</span></span>\n<span><span>\t</span></span>\n<span><span>\tp.x </span><span>=</span><span> </span><span>12</span><span>;</span></span>\n<span><span>\tp.y </span><span>=</span><span> </span><span>34</span><span>;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"p.x=</span><span>%d</span><span>, p.y=</span><span>%d\\n</span><span>"</span><span>, p.x, p.y);</span></span>\n<span><span>\tpoi </span><span>=</span><span> </span><span>&#x26;</span><span>p;</span></span>\n<span><span>\t</span></span>\n<span><span>\t</span><span>// 構造体のポインタ変数からのメンバアクセスには</span></span>\n<span><span>\t</span><span>// -> 演算子を使う</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"poi->x=</span><span>%d</span><span>, poi->y=</span><span>%d\\n</span><span>"</span><span>, poi->x, poi->y);</span></span>\n<span> </span>\n<span><span>\t</span><span>// これと同じ</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"poi->x=</span><span>%d</span><span>, poi->y=</span><span>%d\\n</span><span>"</span><span>, (</span><span>*</span><span>poi).x, (</span><span>*</span><span>poi).y);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>構造体のメモリを動的に確保することも可能です。ちなみに<code>Point2D</code>は<code>int</code>型の変数が2つあるので<code>sizeof(Point2D)</code>は<code>8</code>を返します。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>typedef</span><span> </span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>} Point2D;</span></span>\n<span> </span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\tPoint2D </span><span>*</span><span>p </span><span>=</span><span> (Point2D </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(Point2D) </span><span>*</span><span> </span><span>1</span><span>);</span></span>\n<span><span>\t(</span><span>*</span><span>p).x </span><span>=</span><span> </span><span>12</span><span>;</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, (</span><span>*</span><span>p).x);</span></span>\n<span><span>\tp->x </span><span>=</span><span> </span><span>34</span><span>;</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, p->x);</span></span>\n<span><span>\t</span><span>free</span><span>(p);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>構造体の配列も動的に生成できます。</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>#include</span><span> </span><span>&#x3C;stdlib.h></span></span>\n<span> </span>\n<span><span>typedef</span><span> </span><span>struct</span><span> Point2D {</span></span>\n<span><span>\t</span><span>int</span><span> x, y;</span></span>\n<span><span>} Point2D;</span></span>\n<span> </span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> length;</span></span>\n<span> </span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Input lenght: "</span><span>);</span></span>\n<span><span>\t</span><span>scanf</span><span>(</span><span>"</span><span>%d</span><span>"</span><span>, </span><span>&#x26;</span><span>length);</span></span>\n<span> </span>\n<span><span>\tPoint2D </span><span>*</span><span>p </span><span>=</span><span> (Point2D </span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(Point2D) </span><span>*</span><span> length);</span></span>\n<span><span>\t</span></span>\n<span><span>\t</span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> length; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>p</span><span>[i].x </span><span>=</span><span> i;</span></span>\n<span><span>\t\t</span><span>p</span><span>[i].y </span><span>=</span><span> </span><span>2</span><span> </span><span>*</span><span> i;</span></span>\n<span><span>\t}</span></span>\n<span> </span>\n<span><span>\t</span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> length; i</span><span>++</span><span>){</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"p[</span><span>%d</span><span>].x = </span><span>%d</span><span>, p[</span><span>%d</span><span>].y = </span><span>%d\\n</span><span>"</span><span>, i, </span><span>p</span><span>[i].x, i, </span><span>p</span><span>[i].y);</span></span>\n<span><span>\t}</span></span>\n<span> </span>\n<span><span>\t</span><span>free</span><span>(p);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<pre><code>Input lenght: 10\r\np[0].x = 0, p[0].y = 0\r\np[1].x = 1, p[1].y = 2\r\np[2].x = 2, p[2].y = 4\r\np[3].x = 3, p[3].y = 6\r\np[4].x = 4, p[4].y = 8\r\np[5].x = 5, p[5].y = 10\r\np[6].x = 6, p[6].y = 12\r\np[7].x = 7, p[7].y = 14\r\np[8].x = 8, p[8].y = 16\r\np[9].x = 9, p[9].y = 18\n</code></pre>\n<pre><code>Input lenght: 5\r\np[0].x = 0, p[0].y = 0\r\np[1].x = 1, p[1].y = 2\r\np[2].x = 2, p[2].y = 4\r\np[3].x = 3, p[3].y = 6\r\np[4].x = 4, p[4].y = 8\n</code></pre>\n',
  },
  {
    title: 'MCC C言語部内講習会 第１回',
    description: 'MCC C言語部内講習会 第１回 を行いました。',
    date: '2023-05-26',
    tags: ['dev'],
    rootPath: 'content/blog/2023-05-26-mcc-c-lec-1/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\r\n# MCC C言語部内講習会 第１回\r\n\r\n## この講座の対象の人\r\n - MCC部員\r\n - C言語を初歩から学びたい人\r\n\r\n## 第１回の目次\r\n- [概念編](#概念編)\r\n\t- [Cにおける変数](#cにおける変数)\r\n\t\t- [変数の型とは](#変数の型とは)\r\n\t\t- [配列とは](#配列とは)\r\n\t\t- [多次元配列](#多次元配列)\r\n\t- [Cにおける関数](#cにおける関数)\r\n\t- [Cにおける条件分岐](#cにおける条件分岐)\r\n\t\t- [`if` - `else` 文](#if---else-文)\r\n\t\t- [`switch` - `case` 文](#switch---case-文)\r\n\t- [Cにおけるループ(繰り返し)処理](#cにおけるループ繰り返し処理)\r\n\t\t- [`for` 文](#for-文)\r\n\t\t- [`while` 文(`do` ~ `while` 文)](#while-文do--while-文)\r\n\t\t- [`do` ~ `while` 文](#do--while-文)\r\n- [実践編](#実践編)\r\n\t- [文字の表示](#文字の表示)\r\n\t\t- [演習問題１](#演習問題１)\r\n\t- [変数の内容の表示](#変数の内容の表示)\r\n\t\t- [演習問題２](#演習問題２)\r\n\t- [配列の内容の表示](#配列の内容の表示)\r\n\t\t- [演習問題３](#演習問題３)\r\n- [発展編](#発展編)\r\n\t- [式、文について](#式文について)\r\n\t- [ポインタ(と配列)](#ポインタと配列)\r\n\r\n**この後の内容をチラ見して内容を知っていそうだと判断できる人は次回以降の参加でも大丈夫です！**\r\n\r\n## 概念編\r\n### Cにおける変数\r\nCにおいて、変数は主に次の二つの情報を持っています。\r\n - 型\r\n - 値\r\n - (名前)\r\n  \r\n次に、変数を定義する例を示します。\r\n```c\r\nint i = 0;\r\n```\r\nこれは `i` という名前の変数に `0` という値を代入する文です。  \r\nこの文から、 `i` について\r\n - `int` 型\r\n - `0` で初期化される\r\n\r\nということが読み取れます。これらの情報はプログラマだけでなくコンパイラにとっても重要です。  \r\n\r\n#### 変数の型とは\r\n上で述べたように、変数はそれぞれ**型**という情報を持っています。\r\nここであまり詳しく説明しても理解を妨げるだけなので省略しますが、変数の型についておおむね次のことが言えます。\r\n - 変数が一度に持てる型は1つ\r\n - 型によって変数の取れる値の範囲が異なる\r\n - 変数同士のやり取りより関数とのやり取りの際に重要になる\r\n  \r\n\r\n#### 配列とは\r\n**配列**とは、**一定の長さ**の、**連続した同じ型の値**を持つ変数です。  \r\n次に `int` 型，長さ `3` の配列変数を定義する例を示します。\r\n```c\r\nint arr[3] = {1, 2, 3};\r\n```\r\nまたは、長さを明示せず、次のように書くこともできます。\r\n```c\r\nint arr[] = {1, 2, 3};\r\n```\r\n配列の長さを定義した後に変えることはできません。  \r\nまた、配列の長さを変数で設定することはできません。\r\n```c\r\nint x; scanf("%d", &x); // scanfは外部からの入力を受け取る関数\r\nint a[x] = {1, 2, 3}; // コンパイルエラー！\r\n```\r\n\r\n配列の各要素の値を取得する方法に添え字を用いる方法があります。\r\n```c\r\nint arr[3] = {1, 2, 3};\r\narr[0]; // => 1\r\narr[1]; // => 2\r\narr[2]; // => 3\r\n```\r\nこの際に注意すべきこととして、添え字の値は`(配列の長さ-1)`以下でなければなりません。これは配列の先頭の要素を `0` 番目としているからです。\r\n\r\n#### 多次元配列\r\n配列は、他の配列を要素に持つことができます。簡単な例を示します。\r\n```c\r\nint a[2][2] = { {1, 2}, {3, 4} };\r\n```\r\n上に示したのは2*2の2次元配列です。\r\n多次元配列においても基本的なルールは１次元の配列と変わりません。要素の値を取得する方法を次に示します。\r\n```c\r\nint a[2][2] = { {1, 2}, {3, 4} };\r\na[0][0]; // => 1\r\na[0][1]; // => 2\r\na[1][0]; // => 3\r\na[1][1]; // => 4\r\n\r\n// つまり、a[0] = {1, 2}, a[1] = {3, 4}\r\n```\r\nなお、各次元の要素数を一致させる必要はなく、`int a[2][3]`なども問題ありません。\r\n\r\n### Cにおける関数\r\nCにおいて、**関数**は**複数の処理をまとめたもの**です。  \r\nまた、関数が持つ情報として、次のものがあります。\r\n - 返り値の型\r\n - 引数の型、個数\r\n - (処理の内容)\r\n  \r\n関数の定義の構文を次に示します。\r\n```c\r\n返り値の型 関数名(引数1, 引数2, ...) {\r\n\t関数の内容\r\n}\r\n```\r\n引数の数は特に制限されておらず、 `0` 個の場合もあります。\r\nその場合でも、関数名の直後の括弧を省略することはできません。  \r\n次に簡単な関数の定義の例を示します。 `2` 個の `int` 型の値を引数に取り、 `int` 型の値を返す `add` 関数を考えます。\r\n```c\r\nint add(int a, int b) {\r\n\treturn a+b;\r\n}\r\n```\r\n  \r\nこの関数をほかの関数から呼び出す例を次に示します。(今回は `main` 関数)\r\n```c\r\nint main() {\r\n\tadd(2, 3); // 5\r\n}\r\n```\r\n  \r\nこの関数の返り値を変数に代入して受け取ることもできます。\r\n```c\r\nint main() {\r\n\tint x = add(2, 3); // x = 5\r\n}\r\n```\r\n代入先の変数の型と関数の返り値の型は一致している必要があります。\r\n  \r\n`add` 関数の引数に変数を渡す例を示します。\r\n```c\r\nint main() {\r\n\tint x = 12, y = 30;\r\n\tadd(x, y); // 42\r\n}\r\n```\r\n  \r\nまた、返り値のない関数を定義することもできます。\r\n```c\r\nvoid nothing() {\r\n\tputs("return nothing");\r\n}\r\n```\r\n\r\n### Cにおける条件分岐\r\nCにおいて、**条件分岐**は以下の2つがあります。\r\n - `if` - `else` 文\r\n - `switch` - `case` 文\r\n  \r\n#### `if` - `else` 文\r\n`if` - `else` 文の構文を次に示します。\r\n```c\r\nif (条件1) {\r\n\t処理1\r\n} else if (条件2) {\r\n\t処理2\r\n} else {\r\n\t処理3\r\n}\r\n```\r\n最初の `if` 文を省略することはできませんが、`else if` 、また `else` 節は必要に応じて省略することが可能です。省略した例を次に示します。\r\n```c\r\n// else 節のみ省略\r\nif (条件1) {\r\n\t処理1\r\n} else if (条件2) {\r\n\t処理2\r\n}\r\n\r\n// else if 節を省略\r\nif (条件3) {\r\n\t処理3\r\n} else {\r\n\t処理4\r\n}\r\n\r\n// 条件に当てはまらなかった時に特に何もする必要がない場合、 else 節、 else if 節をともに省略することができます\r\nif (条件4) {\r\n\t処理5\r\n}\r\n```\r\n\r\n#### `switch` - `case` 文\r\n`switch` - `case` 文は `if` - `else` 文と機能的に似ているように見える文法ですが、いくつかの相違点があります。\r\n例を示しながら、相違点を解説していきます。\r\n  \r\n```c\r\nswitch (式1) {\r\ncase 値1:\r\n\t処理1\r\n\tbreak;\r\ncase 値2:\r\n\t処理2\r\n\tbreak;\r\ndefault:\r\n\t処理3\r\n\tbreak;\r\n}\r\n```\r\n上の例を `if` - `else` 文で書くと次のようになります。  \r\n```c\r\nif (式1 == 値1) {\r\n\t処理1\r\n} else if (式2 == 値2) {\r\n\t処理2\r\n} else {\r\n\t処理3\r\n}\r\n```\r\n`if` - `else` 文と `switch` - `case` 文の相違点として、「`if` - `else` 文は条件(式)の真偽(値が1か0か)のみで分岐するのに対し、`switch` - `case` 文は1つの式に対してその値で分岐する」というものがあります。\r\n(書いてから気づいたんですが、この文章は式とか文とか用語の説明をしなければいけないので、後に回したい。)  \r\nまた、`switch` - `case` 文では処理を書いたあとに(続けて次の条件の処理を必ず行いたいのでない限り)、 `break` 文を書かなければならないという点も異なります。\r\nこの文章では何が言いたいのか分かりにくいと思われるので、次にソースコードとその出力を示して説明します。  \r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tint x = 4;\r\n\r\n\tswitch (x) {\r\n\tcase 2:\r\n\t\tputs("two!");\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tputs("four!");\r\n\t\t// break を書き忘れてしまった!\r\n\tcase 6:\r\n\t\tputs("six!");\r\n\t\tbreak;\r\n\tcase 8:\r\n\t\tputs("eight!");\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tputs("not supported!");\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n  \r\nさて、上に示したのは `int` 型の変数 `x` に対して分岐する単純なコードです。これをコンパイルして実行すると、\r\n```\r\nfour!\r\nsix!\r\n```\r\nという出力が得られます。 `x` を他の数(`2`, `6`, `8`)に変更するとそれに対応した英単語単体が出力されると思います。  \r\nではなぜ `4` の時のみ `six!` という単語も出力されてしまうのかというと、`case 4:` に `break` 文を書き忘れてしまったためなのです。  \r\nつまり、 `swtich` - `case` 文においては、各ケースに対して `break` 文を1つ書かないと自動的に次の `case` の処理に突入してしまうのです。\r\n(ソースコードを見れば明らかかと思いますが、条件式の値が `case` の値と異なっていても突入してしまいます。)\r\n\r\n### Cにおけるループ(繰り返し)処理\r\nCにおいて、ループ(繰り返し)処理は以下の2種類があります。\r\n - `for` 文\r\n - `while` 文(`do` ~ `while` 文)\r\n  \r\n#### `for` 文\r\n`for` 文は次のような構文で表されるループ処理です。\r\n```c\r\nfor (ループ用変数初期化式; ループ継続条件式; ループ用変数更新式) {\r\n\t処理\r\n}\r\n```\r\n具体的な例として、1~10を数え上げるコードを紹介します。\r\n```c\r\nfor (int i = 1; i <= 10; ++i) {\r\n\tprintf("%d\\n", i);\r\n}\r\n```\r\n上記の構文と具体例を見比べてみます。  \r\n`int i = 1` はループ用の変数 `i` の初期化式です。\r\nループ用変数とは、ループ継続条件式の真偽判定に使用する変数のことです。`for` 文以前で定義した変数を使用することもできます。  \r\n`i <= 10` はループ継続条件式です。\r\nこの条件式を**満たさなくなったとき**にループは終了します。この条件式の判定は毎回のループの直前に行われます。\r\nつまり初回ループ実行前にも行われるため、ループ内の処理が一度も行われないこともあり得ます。\r\nループ内の処理を必ず一度は行いたい場合、後述する [`do` ~ `while` 文](#do--while-文)を使用する必要があります。  \r\n`++i` はループ用変数更新式です。**ループ用の変数を変化させるための式**をここに記述します。\r\nちなみにここに書かずにループの処理内に書くこともできますが、コードの可読性のためにこの部分に書くことをおすすめします。\r\n(`for` 文でここ以外にループ用変数を変化させる式を書く人見たことない気がします。)\r\n\r\n#### `while` 文(`do` ~ `while` 文)\r\n`while` 文は次のような構文で表されるループ処理です。\r\n```c\r\nwhile (ループ継続条件式) {\r\n\t処理\r\n}\r\n```\r\n具体例として、 `for` 文のセクションで紹介した、1~10を数え上げるコードを `while` 文で書いてみます。\r\n```c\r\nint i = 1;\r\nwhile (i <= 10) {\r\n\tprintf("%d\\n", i);\r\n\t++i;\r\n}\r\n```\r\n`for` 文との違いとして、ループ用変数の初期化を `while` より前に書いていること、ループ用変数更新式をループ処理内に書いていることが挙げられます。\r\nこれによって、`for` 文と異なり、**ループ用変数更新式を条件によって実行/スキップすることが容易**になっています。\r\n(個人的には、情報が散逸して読みにくくなるため、更新式をスキップしたりするわけでなければ素直に `for` 文を使う方が好きです。)  \r\n  \r\n#### `do` ~ `while` 文\r\n`do` ~ `while` 文は、**ループの初回で条件チェックがない**ことを除けば、前述した `while` 文と機能は同じです。構文と具体例を示します。\r\n```c\r\ndo {\r\n\t処理\r\n} while (ループ継続条件式);\r\n```\r\n\r\n```c\r\nint i = 5;\r\ndo {\r\n\tprintf("%d\\n", i);\r\n\t++i;\r\n} while (i < 2);\r\n// "5"のみ表示されてループ終了\r\n// 通常の while 文では"5"すらも表示されない\r\n```\r\n\r\n## 実践編\r\n### 文字の表示\r\n例\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tprintf("Hello, MCC!\\n");\r\n\treturn 0;\r\n}\r\n```\r\n実行すると `Hello, MCC!`という文字列が改行とともに表示されます。\r\n\r\n#### 演習問題１\r\n以下のテンプレートを用いて自分のDiscordの名前を改行とともに表示してください。  \r\n\r\nテンプレート\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n<details>\r\n<summary>演習問題１の模範解答</summary><div>\r\n\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tprintf("SSSato\\n");\r\n\treturn 0;\r\n}\r\n```\r\n\r\n</div></details>\r\n  \r\n\r\n### 変数の内容の表示\r\n変数の内容を `printf` 関数を用いて表示してみましょう。  \r\n例\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tint x = 42;\r\n\tprintf("%d\\n", x);\r\n\treturn 0;\r\n}\r\n```\r\n出力\r\n```\r\n42\r\n```\r\n`printf` 関数の引数に渡されている文字列に含まれている `%d` という文字列は「フォーマット指定子」と呼ばれ、`printf` 関数の第二引数以降に渡された値をどの型の値として解釈して表示するかを指定するものです。主要なフォーマット指定子には符号付き整数(`int`)の `%d` 、符号付き倍精度浮動小数点数(`double`)の `%lf` 、の符号付き文字(`char`)の `%c` 、`char`型ポインタ(文字列)の `%s` などがあります。(今覚える必要はないです。必要になった場面で毎回調べるたびに覚えるので。)\r\n\r\n#### 演習問題２\r\n次のテンプレートの `printf` 関数の第一引数内の"?"を適切なフォーマット指定子に変更して、`c` をそれぞれ整数(`int`)、文字(`char`)として解釈した結果を表示してください。  \r\nテンプレート\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tchar c = 65;\r\n\tprintf("%?, %?\\n", c, c);\r\n\treturn 0;\r\n}\r\n```\r\n期待する出力\r\n```\r\n65, A\r\n```\r\nこの出力から分かる通り、ASCIIにおいて、`\'A\'`の文字コードは`65`です\r\n<details>\r\n<summary>演習問題２の模範解答</summary><div>\r\n\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tchar c = 65;\r\n\tprintf("%d, %c\\n", c, c);\r\n\treturn 0;\r\n}\r\n```\r\n\r\n</div></details>  \r\n  \r\n　　\r\n### 配列の内容の表示\r\n配列変数の各要素を `printf` 関数を用いて表示してみましょう。  \r\n例\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tint arr[] = {12, 124, 1245};\r\n\tfor (int i = 0; i < 3; ++i) {\r\n\t\tprintf("%d\\n", arr[i]);\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n出力\r\n```\r\n12\r\n124\r\n1245\r\n```\r\n#### 演習問題３\r\n多次元配列の各要素を表示してください。  \r\n若干難易度が高いので、少し考えてコードが書けそうにない場合は模範解答を開いてしまってかまいません。  \r\nテンプレート\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tint arr[3][3] = {{12, 23, 34}, {54, 43, 32}, {46, 57, 68}};\r\n\t/* コードをここに書く */\r\n\treturn 0;\r\n}\r\n```\r\n<details>\r\n<summary>演習問題３のヒント</summary><div>\r\n\r\n二重ループを使います\r\n\r\n</div></details>  \r\n\r\n\r\n<details>\r\n<summary>演習問題３の模範解答</summary><div>\r\n\r\n```c\r\n#include <stdio.h>\r\nint main() {\r\n\tint arr[3][3] = {{12, 23, 34}, {54, 43, 32}, {46, 57, 68}};\r\n\tfor (int i = 0; i < 3; ++i) {\r\n\t\tfor (int j = 0; j < 3; ++j) {\r\n\t\t\tprintf("%d ", arr[i][j]);\r\n\t\t}\r\n\t\tprintf("\\n");\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n出力\r\n```\r\n12 23 34 \r\n54 43 32 \r\n46 57 68 \r\n```\r\n\r\n</div></details>  \r\n\r\n## 発展編\r\n### 式、文について\r\n式は値を返す。文は値を返さない。`1+1` は式。`if` 文や `switch` - `case`文は文だから値を返さない。`if` とか `switch` の括弧に入れられるやつは式。\r\n\r\n### ポインタ(と配列)\r\n書こうと思ったけど第二回に持ち越した方がよさそうな気がしたので持ち越します。\r\n',
    html: '\n<h1 id="user-content-mcc-c言語部内講習会-第１回">MCC C言語部内講習会 第１回</h1>\n<h2 id="user-content-この講座の対象の人">この講座の対象の人</h2>\n<ul>\n  <li>MCC部員</li>\n  <li>C言語を初歩から学びたい人</li>\n</ul>\n<h2 id="user-content-第１回の目次">第１回の目次</h2>\n<ul>\n  <li><a href="#%E6%A6%82%E5%BF%B5%E7%B7%A8">概念編</a>\n    <ul>\n      <li><a href="#c%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%A4%89%E6%95%B0">Cにおける変数</a>\n        <ul>\n          <li><a href="#%E5%A4%89%E6%95%B0%E3%81%AE%E5%9E%8B%E3%81%A8%E3%81%AF">変数の型とは</a></li>\n          <li><a href="#%E9%85%8D%E5%88%97%E3%81%A8%E3%81%AF">配列とは</a></li>\n          <li><a href="#%E5%A4%9A%E6%AC%A1%E5%85%83%E9%85%8D%E5%88%97">多次元配列</a></li>\n        </ul>\n      </li>\n      <li><a href="#c%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E9%96%A2%E6%95%B0">Cにおける関数</a></li>\n      <li><a href="#c%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90">Cにおける条件分岐</a>\n        <ul>\n          <li><a href="#if---else-%E6%96%87"><code>if</code> - <code>else</code> 文</a></li>\n          <li><a href="#switch---case-%E6%96%87"><code>switch</code> - <code>case</code> 文</a></li>\n        </ul>\n      </li>\n      <li><a href="#c%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%83%AB%E3%83%BC%E3%83%97%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97%E5%87%A6%E7%90%86">Cにおけるループ(繰り返し)処理</a>\n        <ul>\n          <li><a href="#for-%E6%96%87"><code>for</code> 文</a></li>\n          <li><a href="#while-%E6%96%87do--while-%E6%96%87"><code>while</code> 文(<code>do</code> ~ <code>while</code> 文)</a></li>\n          <li><a href="#do--while-%E6%96%87"><code>do</code> ~ <code>while</code> 文</a></li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><a href="#%E5%AE%9F%E8%B7%B5%E7%B7%A8">実践編</a>\n    <ul>\n      <li><a href="#%E6%96%87%E5%AD%97%E3%81%AE%E8%A1%A8%E7%A4%BA">文字の表示</a>\n        <ul>\n          <li><a href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C%EF%BC%91">演習問題１</a></li>\n        </ul>\n      </li>\n      <li><a href="#%E5%A4%89%E6%95%B0%E3%81%AE%E5%86%85%E5%AE%B9%E3%81%AE%E8%A1%A8%E7%A4%BA">変数の内容の表示</a>\n        <ul>\n          <li><a href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C%EF%BC%92">演習問題２</a></li>\n        </ul>\n      </li>\n      <li><a href="#%E9%85%8D%E5%88%97%E3%81%AE%E5%86%85%E5%AE%B9%E3%81%AE%E8%A1%A8%E7%A4%BA">配列の内容の表示</a>\n        <ul>\n          <li><a href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C%EF%BC%93">演習問題３</a></li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><a href="#%E7%99%BA%E5%B1%95%E7%B7%A8">発展編</a>\n    <ul>\n      <li><a href="#%E5%BC%8F%E6%96%87%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">式、文について</a></li>\n      <li><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%A8%E9%85%8D%E5%88%97">ポインタ(と配列)</a></li>\n    </ul>\n  </li>\n</ul>\n<p><strong>この後の内容をチラ見して内容を知っていそうだと判断できる人は次回以降の参加でも大丈夫です！</strong></p>\n<h2 id="user-content-概念編">概念編</h2>\n<h3 id="user-content-cにおける変数">Cにおける変数</h3>\n<p>Cにおいて、変数は主に次の二つの情報を持っています。</p>\n<ul>\n  <li>型</li>\n  <li>値</li>\n  <li>(名前)</li>\n</ul>\n<p>次に、変数を定義する例を示します。</p>\n<div>\n  <pre><code><span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span></span></code></pre>\n</div>\n<p>これは <code>i</code> という名前の変数に <code>0</code> という値を代入する文です。<br>この文から、 <code>i</code> について</p>\n<ul>\n  <li><code>int</code> 型</li>\n  <li><code>0</code> で初期化される</li>\n</ul>\n<p>ということが読み取れます。これらの情報はプログラマだけでなくコンパイラにとっても重要です。</p>\n<h4 id="user-content-変数の型とは">変数の型とは</h4>\n<p>\n  上で述べたように、変数はそれぞれ<strong>型</strong>という情報を持っています。\r\n  ここであまり詳しく説明しても理解を妨げるだけなので省略しますが、変数の型についておおむね次のことが言えます。\n</p>\n<ul>\n  <li>変数が一度に持てる型は1つ</li>\n  <li>型によって変数の取れる値の範囲が異なる</li>\n  <li>変数同士のやり取りより関数とのやり取りの際に重要になる</li>\n</ul>\n<h4 id="user-content-配列とは">配列とは</h4>\n<p><strong>配列</strong>とは、<strong>一定の長さ</strong>の、<strong>連続した同じ型の値</strong>を持つ変数です。<br>次に <code>int</code> 型，長さ <code>3</code> の配列変数を定義する例を示します。</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>arr</span><span>[</span><span>3</span><span>] </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>};</span></span></code></pre>\n</div>\n<p>または、長さを明示せず、次のように書くこともできます。</p>\n<div>\n  <pre><code><span><span>int</span><span> arr</span><span>[]</span><span> </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>};</span></span></code></pre>\n</div>\n<p>配列の長さを定義した後に変えることはできません。<br>また、配列の長さを変数で設定することはできません。</p>\n<div>\n  <pre><code><span><span>int</span><span> x; </span><span>scanf</span><span>(</span><span>"</span><span>%d</span><span>"</span><span>, </span><span>&#x26;</span><span>x</span><span>);</span><span> // scanfは外部からの入力を受け取る関数</span></span>\n<span><span>int</span><span> </span><span>a</span><span>[x] </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>};</span><span> // コンパイルエラー！</span></span></code></pre>\n</div>\n<p>配列の各要素の値を取得する方法に添え字を用いる方法があります。</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>arr</span><span>[</span><span>3</span><span>] </span><span>=</span><span> {</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>};</span></span>\n<span><span>arr</span><span>[</span><span>0</span><span>];</span><span> // => 1</span></span>\n<span><span>arr</span><span>[</span><span>1</span><span>];</span><span> // => 2</span></span>\n<span><span>arr</span><span>[</span><span>2</span><span>];</span><span> // => 3</span></span></code></pre>\n</div>\n<p>この際に注意すべきこととして、添え字の値は<code>(配列の長さ-1)</code>以下でなければなりません。これは配列の先頭の要素を <code>0</code> 番目としているからです。</p>\n<h4 id="user-content-多次元配列">多次元配列</h4>\n<p>配列は、他の配列を要素に持つことができます。簡単な例を示します。</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>a</span><span>[</span><span>2</span><span>][</span><span>2</span><span>] </span><span>=</span><span> { {</span><span>1</span><span>, </span><span>2</span><span>}, {</span><span>3</span><span>, </span><span>4</span><span>} };</span></span></code></pre>\n</div>\n<p>\n  上に示したのは2*2の2次元配列です。\r\n  多次元配列においても基本的なルールは１次元の配列と変わりません。要素の値を取得する方法を次に示します。\n</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>a</span><span>[</span><span>2</span><span>][</span><span>2</span><span>] </span><span>=</span><span> { {</span><span>1</span><span>, </span><span>2</span><span>}, {</span><span>3</span><span>, </span><span>4</span><span>} };</span></span>\n<span><span>a</span><span>[</span><span>0</span><span>][</span><span>0</span><span>];</span><span> // => 1</span></span>\n<span><span>a</span><span>[</span><span>0</span><span>][</span><span>1</span><span>];</span><span> // => 2</span></span>\n<span><span>a</span><span>[</span><span>1</span><span>][</span><span>0</span><span>];</span><span> // => 3</span></span>\n<span><span>a</span><span>[</span><span>1</span><span>][</span><span>1</span><span>];</span><span> // => 4</span></span>\n<span> </span>\n<span><span>// つまり、a[0] = {1, 2}, a[1] = {3, 4}</span></span></code></pre>\n</div>\n<p>なお、各次元の要素数を一致させる必要はなく、<code>int a[2][3]</code>なども問題ありません。</p>\n<h3 id="user-content-cにおける関数">Cにおける関数</h3>\n<p>Cにおいて、<strong>関数</strong>は<strong>複数の処理をまとめたもの</strong>です。<br>また、関数が持つ情報として、次のものがあります。</p>\n<ul>\n  <li>返り値の型</li>\n  <li>引数の型、個数</li>\n  <li>(処理の内容)</li>\n</ul>\n<p>関数の定義の構文を次に示します。</p>\n<div>\n  <pre><code><span><span>返り値の型 関数名(引数1, 引数2, ...) {</span></span>\n<span><span>\t関数の内容</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  引数の数は特に制限されておらず、 <code>0</code> 個の場合もあります。\r\n  その場合でも、関数名の直後の括弧を省略することはできません。<br>次に簡単な関数の定義の例を示します。 <code>2</code> 個の <code>int</code> 型の値を引数に取り、 <code>int</code> 型の値を返す <code>add</code> 関数を考えます。\n</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>add</span><span>(</span><span>int</span><span> </span><span>a</span><span>, </span><span>int</span><span> </span><span>b</span><span>) {</span></span>\n<span><span>\t</span><span>return</span><span> a</span><span>+</span><span>b;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>この関数をほかの関数から呼び出す例を次に示します。(今回は <code>main</code> 関数)</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>add</span><span>(</span><span>2</span><span>, </span><span>3</span><span>);</span><span> // 5</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>この関数の返り値を変数に代入して受け取ることもできます。</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> x </span><span>=</span><span> </span><span>add</span><span>(</span><span>2</span><span>, </span><span>3</span><span>);</span><span> // x = 5</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>代入先の変数の型と関数の返り値の型は一致している必要があります。</p>\n<p><code>add</code> 関数の引数に変数を渡す例を示します。</p>\n<div>\n  <pre><code><span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> x </span><span>=</span><span> </span><span>12</span><span>, y </span><span>=</span><span> </span><span>30</span><span>;</span></span>\n<span><span>\t</span><span>add</span><span>(x, y);</span><span> // 42</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>また、返り値のない関数を定義することもできます。</p>\n<div>\n  <pre><code><span><span>void</span><span> </span><span>nothing</span><span>() {</span></span>\n<span><span>\t</span><span>puts</span><span>(</span><span>"return nothing"</span><span>);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<h3 id="user-content-cにおける条件分岐">Cにおける条件分岐</h3>\n<p>Cにおいて、<strong>条件分岐</strong>は以下の2つがあります。</p>\n<ul>\n  <li><code>if</code> - <code>else</code> 文</li>\n  <li><code>switch</code> - <code>case</code> 文</li>\n</ul>\n<h4 id="user-content-if---else-文"><code>if</code> - <code>else</code> 文</h4>\n<p><code>if</code> - <code>else</code> 文の構文を次に示します。</p>\n<div>\n  <pre><code><span><span>if</span><span> (条件1) {</span></span>\n<span><span>\t処理1</span></span>\n<span><span>} </span><span>else</span><span> </span><span>if</span><span> (条件2) {</span></span>\n<span><span>\t処理2</span></span>\n<span><span>} </span><span>else</span><span> {</span></span>\n<span><span>\t処理3</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>最初の <code>if</code> 文を省略することはできませんが、<code>else if</code> 、また <code>else</code> 節は必要に応じて省略することが可能です。省略した例を次に示します。</p>\n<div>\n  <pre><code><span><span>// else 節のみ省略</span></span>\n<span><span>if</span><span> (条件1) {</span></span>\n<span><span>\t処理1</span></span>\n<span><span>} </span><span>else</span><span> </span><span>if</span><span> (条件2) {</span></span>\n<span><span>\t処理2</span></span>\n<span><span>}</span></span>\n<span> </span>\n<span><span>// else if 節を省略</span></span>\n<span><span>if</span><span> (条件3) {</span></span>\n<span><span>\t処理3</span></span>\n<span><span>} </span><span>else</span><span> {</span></span>\n<span><span>\t処理4</span></span>\n<span><span>}</span></span>\n<span> </span>\n<span><span>// 条件に当てはまらなかった時に特に何もする必要がない場合、 else 節、 else if 節をともに省略することができます</span></span>\n<span><span>if</span><span> (条件4) {</span></span>\n<span><span>\t処理5</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<h4 id="user-content-switch---case-文"><code>switch</code> - <code>case</code> 文</h4>\n<p>\n  <code>switch</code> - <code>case</code> 文は <code>if</code> - <code>else</code> 文と機能的に似ているように見える文法ですが、いくつかの相違点があります。\r\n  例を示しながら、相違点を解説していきます。\n</p>\n<div>\n  <pre><code><span><span>switch</span><span> (式1) {</span></span>\n<span><span>case</span><span> 値1:</span></span>\n<span><span>\t処理1</span></span>\n<span><span>\t</span><span>break</span><span>;</span></span>\n<span><span>case</span><span> 値2:</span></span>\n<span><span>\t処理2</span></span>\n<span><span>\t</span><span>break</span><span>;</span></span>\n<span><span>default</span><span>:</span></span>\n<span><span>\t処理3</span></span>\n<span><span>\t</span><span>break</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>上の例を <code>if</code> - <code>else</code> 文で書くと次のようになります。</p>\n<div>\n  <pre><code><span><span>if</span><span> (式1 </span><span>==</span><span> 値1) {</span></span>\n<span><span>\t処理1</span></span>\n<span><span>} </span><span>else</span><span> </span><span>if</span><span> (式2 </span><span>==</span><span> 値2) {</span></span>\n<span><span>\t処理2</span></span>\n<span><span>} </span><span>else</span><span> {</span></span>\n<span><span>\t処理3</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  <code>if</code> - <code>else</code> 文と <code>switch</code> - <code>case</code> 文の相違点として、「<code>if</code> - <code>else</code> 文は条件(式)の真偽(値が1か0か)のみで分岐するのに対し、<code>switch</code> - <code>case</code> 文は1つの式に対してその値で分岐する」というものがあります。\r\n  (書いてから気づいたんですが、この文章は式とか文とか用語の説明をしなければいけないので、後に回したい。)<br>また、<code>switch</code> - <code>case</code> 文では処理を書いたあとに(続けて次の条件の処理を必ず行いたいのでない限り)、 <code>break</code> 文を書かなければならないという点も異なります。\r\n  この文章では何が言いたいのか分かりにくいと思われるので、次にソースコードとその出力を示して説明します。\n</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> x </span><span>=</span><span> </span><span>4</span><span>;</span></span>\n<span> </span>\n<span><span>\t</span><span>switch</span><span> (x) {</span></span>\n<span><span>\t</span><span>case</span><span> </span><span>2</span><span>:</span></span>\n<span><span>\t\t</span><span>puts</span><span>(</span><span>"two!"</span><span>);</span></span>\n<span><span>\t\t</span><span>break</span><span>;</span></span>\n<span><span>\t</span><span>case</span><span> </span><span>4</span><span>:</span></span>\n<span><span>\t\t</span><span>puts</span><span>(</span><span>"four!"</span><span>);</span></span>\n<span><span>\t\t</span><span>// break を書き忘れてしまった!</span></span>\n<span><span>\t</span><span>case</span><span> </span><span>6</span><span>:</span></span>\n<span><span>\t\t</span><span>puts</span><span>(</span><span>"six!"</span><span>);</span></span>\n<span><span>\t\t</span><span>break</span><span>;</span></span>\n<span><span>\t</span><span>case</span><span> </span><span>8</span><span>:</span></span>\n<span><span>\t\t</span><span>puts</span><span>(</span><span>"eight!"</span><span>);</span></span>\n<span><span>\t\t</span><span>break</span><span>;</span></span>\n<span><span>\t</span><span>default</span><span>:</span></span>\n<span><span>\t\t</span><span>puts</span><span>(</span><span>"not supported!"</span><span>);</span></span>\n<span><span>\t\t</span><span>break</span><span>;</span></span>\n<span><span>\t}</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>さて、上に示したのは <code>int</code> 型の変数 <code>x</code> に対して分岐する単純なコードです。これをコンパイルして実行すると、</p>\n<pre><code>four!\r\nsix!\n</code></pre>\n<p>\n  という出力が得られます。 <code>x</code> を他の数(<code>2</code>, <code>6</code>, <code>8</code>)に変更するとそれに対応した英単語単体が出力されると思います。<br>ではなぜ <code>4</code> の時のみ <code>six!</code> という単語も出力されてしまうのかというと、<code>case 4:</code> に <code>break</code> 文を書き忘れてしまったためなのです。<br>つまり、 <code>swtich</code> - <code>case</code> 文においては、各ケースに対して <code>break</code> 文を1つ書かないと自動的に次の <code>case</code> の処理に突入してしまうのです。\r\n  (ソースコードを見れば明らかかと思いますが、条件式の値が <code>case</code> の値と異なっていても突入してしまいます。)\n</p>\n<h3 id="user-content-cにおけるループ繰り返し処理">Cにおけるループ(繰り返し)処理</h3>\n<p>Cにおいて、ループ(繰り返し)処理は以下の2種類があります。</p>\n<ul>\n  <li><code>for</code> 文</li>\n  <li><code>while</code> 文(<code>do</code> ~ <code>while</code> 文)</li>\n</ul>\n<h4 id="user-content-for-文"><code>for</code> 文</h4>\n<p><code>for</code> 文は次のような構文で表されるループ処理です。</p>\n<div>\n  <pre><code><span><span>for</span><span> (ループ用変数初期化式; ループ継続条件式; ループ用変数更新式) {</span></span>\n<span><span>\t処理</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>具体的な例として、1~10を数え上げるコードを紹介します。</p>\n<div>\n  <pre><code><span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>1</span><span>; i </span><span>&#x3C;=</span><span> </span><span>10</span><span>; </span><span>++</span><span>i) {</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, i);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  上記の構文と具体例を見比べてみます。<br><code>int i = 1</code> はループ用の変数 <code>i</code> の初期化式です。\r\n  ループ用変数とは、ループ継続条件式の真偽判定に使用する変数のことです。<code>for</code> 文以前で定義した変数を使用することもできます。<br><code>i &#x3C;= 10</code> はループ継続条件式です。\r\n  この条件式を<strong>満たさなくなったとき</strong>にループは終了します。この条件式の判定は毎回のループの直前に行われます。\r\n  つまり初回ループ実行前にも行われるため、ループ内の処理が一度も行われないこともあり得ます。\r\n  ループ内の処理を必ず一度は行いたい場合、後述する <a href="#do--while-%E6%96%87"><code>do</code> ~ <code>while</code> 文</a>を使用する必要があります。<br><code>++i</code> はループ用変数更新式です。<strong>ループ用の変数を変化させるための式</strong>をここに記述します。\r\n  ちなみにここに書かずにループの処理内に書くこともできますが、コードの可読性のためにこの部分に書くことをおすすめします。\r\n  (<code>for</code> 文でここ以外にループ用変数を変化させる式を書く人見たことない気がします。)\n</p>\n<h4 id="user-content-while-文do--while-文"><code>while</code> 文(<code>do</code> ~ <code>while</code> 文)</h4>\n<p><code>while</code> 文は次のような構文で表されるループ処理です。</p>\n<div>\n  <pre><code><span><span>while</span><span> (ループ継続条件式) {</span></span>\n<span><span>\t処理</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>具体例として、 <code>for</code> 文のセクションで紹介した、1~10を数え上げるコードを <code>while</code> 文で書いてみます。</p>\n<div>\n  <pre><code><span><span>int</span><span> i </span><span>=</span><span> </span><span>1</span><span>;</span></span>\n<span><span>while</span><span> (i </span><span>&#x3C;=</span><span> </span><span>10</span><span>) {</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, i);</span></span>\n<span><span>\t</span><span>++</span><span>i;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  <code>for</code> 文との違いとして、ループ用変数の初期化を <code>while</code> より前に書いていること、ループ用変数更新式をループ処理内に書いていることが挙げられます。\r\n  これによって、<code>for</code> 文と異なり、<strong>ループ用変数更新式を条件によって実行/スキップすることが容易</strong>になっています。\r\n  (個人的には、情報が散逸して読みにくくなるため、更新式をスキップしたりするわけでなければ素直に <code>for</code> 文を使う方が好きです。)\n</p>\n<h4 id="user-content-do--while-文"><code>do</code> ~ <code>while</code> 文</h4>\n<p><code>do</code> ~ <code>while</code> 文は、<strong>ループの初回で条件チェックがない</strong>ことを除けば、前述した <code>while</code> 文と機能は同じです。構文と具体例を示します。</p>\n<div>\n  <pre><code><span><span>do</span><span> {</span></span>\n<span><span>\t処理</span></span>\n<span><span>} </span><span>while</span><span> (ループ継続条件式);</span></span></code></pre>\n</div>\n<div>\n  <pre><code><span><span>int</span><span> i </span><span>=</span><span> </span><span>5</span><span>;</span></span>\n<span><span>do</span><span> {</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, i);</span></span>\n<span><span>\t</span><span>++</span><span>i;</span></span>\n<span><span>} </span><span>while</span><span> (i </span><span>&#x3C;</span><span> </span><span>2</span><span>);</span></span>\n<span><span>// "5"のみ表示されてループ終了</span></span>\n<span><span>// 通常の while 文では"5"すらも表示されない</span></span></code></pre>\n</div>\n<h2 id="user-content-実践編">実践編</h2>\n<h3 id="user-content-文字の表示">文字の表示</h3>\n<p>例</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"Hello, MCC!</span><span>\\n</span><span>"</span><span>);</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>実行すると <code>Hello, MCC!</code>という文字列が改行とともに表示されます。</p>\n<h4 id="user-content-演習問題１">演習問題１</h4>\n<p>以下のテンプレートを用いて自分のDiscordの名前を改行とともに表示してください。</p>\n<p>テンプレート</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<details>\n  <summary>演習問題１の模範解答</summary>\n  <div>\n    <div>\n      <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"SSSato</span><span>\\n</span><span>"</span><span>);</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n    </div>\n  </div>\n</details>\n<h3 id="user-content-変数の内容の表示">変数の内容の表示</h3>\n<p>変数の内容を <code>printf</code> 関数を用いて表示してみましょう。<br>例</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> x </span><span>=</span><span> </span><span>42</span><span>;</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, x);</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>出力</p>\n<pre><code>42\n</code></pre>\n<p><code>printf</code> 関数の引数に渡されている文字列に含まれている <code>%d</code> という文字列は「フォーマット指定子」と呼ばれ、<code>printf</code> 関数の第二引数以降に渡された値をどの型の値として解釈して表示するかを指定するものです。主要なフォーマット指定子には符号付き整数(<code>int</code>)の <code>%d</code> 、符号付き倍精度浮動小数点数(<code>double</code>)の <code>%lf</code> 、の符号付き文字(<code>char</code>)の <code>%c</code> 、<code>char</code>型ポインタ(文字列)の <code>%s</code> などがあります。(今覚える必要はないです。必要になった場面で毎回調べるたびに覚えるので。)</p>\n<h4 id="user-content-演習問題２">演習問題２</h4>\n<p>次のテンプレートの <code>printf</code> 関数の第一引数内の"?"を適切なフォーマット指定子に変更して、<code>c</code> をそれぞれ整数(<code>int</code>)、文字(<code>char</code>)として解釈した結果を表示してください。<br>テンプレート</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>char</span><span> c </span><span>=</span><span> </span><span>65</span><span>;</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%</span><span>?, </span><span>%</span><span>?</span><span>\\n</span><span>"</span><span>, c, c);</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>期待する出力</p>\n<pre><code>65, A\n</code></pre>\n<p>この出力から分かる通り、ASCIIにおいて、<code>\'A\'</code>の文字コードは<code>65</code>です</p>\n<details>\n  <summary>演習問題２の模範解答</summary>\n  <div>\n    <div>\n      <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>char</span><span> c </span><span>=</span><span> </span><span>65</span><span>;</span></span>\n<span><span>\t</span><span>printf</span><span>(</span><span>"</span><span>%d</span><span>, </span><span>%c\\n</span><span>"</span><span>, c, c);</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n    </div>\n  </div>\n</details>\n<p>　　</p>\n<h3 id="user-content-配列の内容の表示">配列の内容の表示</h3>\n<p>配列変数の各要素を <code>printf</code> 関数を用いて表示してみましょう。<br>例</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> arr</span><span>[]</span><span> </span><span>=</span><span> {</span><span>12</span><span>, </span><span>124</span><span>, </span><span>1245</span><span>};</span></span>\n<span><span>\t</span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>3</span><span>; </span><span>++</span><span>i) {</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"</span><span>%d\\n</span><span>"</span><span>, </span><span>arr</span><span>[i]);</span></span>\n<span><span>\t}</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>出力</p>\n<pre><code>12\r\n124\r\n1245\n</code></pre>\n<h4 id="user-content-演習問題３">演習問題３</h4>\n<p>多次元配列の各要素を表示してください。<br>若干難易度が高いので、少し考えてコードが書けそうにない場合は模範解答を開いてしまってかまいません。<br>テンプレート</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>arr</span><span>[</span><span>3</span><span>][</span><span>3</span><span>] </span><span>=</span><span> {{</span><span>12</span><span>, </span><span>23</span><span>, </span><span>34</span><span>}, {</span><span>54</span><span>, </span><span>43</span><span>, </span><span>32</span><span>}, {</span><span>46</span><span>, </span><span>57</span><span>, </span><span>68</span><span>}};</span></span>\n<span><span>\t/* コードをここに書く */</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<details>\n  <summary>演習問題３のヒント</summary>\n  <div>\n    <p>二重ループを使います</p>\n  </div>\n</details>\n<details>\n  <summary>演習問題３の模範解答</summary>\n  <div>\n    <div>\n      <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>\t</span><span>int</span><span> </span><span>arr</span><span>[</span><span>3</span><span>][</span><span>3</span><span>] </span><span>=</span><span> {{</span><span>12</span><span>, </span><span>23</span><span>, </span><span>34</span><span>}, {</span><span>54</span><span>, </span><span>43</span><span>, </span><span>32</span><span>}, {</span><span>46</span><span>, </span><span>57</span><span>, </span><span>68</span><span>}};</span></span>\n<span><span>\t</span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&#x3C;</span><span> </span><span>3</span><span>; </span><span>++</span><span>i) {</span></span>\n<span><span>\t\t</span><span>for</span><span> (</span><span>int</span><span> j </span><span>=</span><span> </span><span>0</span><span>; j </span><span>&#x3C;</span><span> </span><span>3</span><span>; </span><span>++</span><span>j) {</span></span>\n<span><span>\t\t\t</span><span>printf</span><span>(</span><span>"</span><span>%d</span><span> "</span><span>, </span><span>arr</span><span>[i][j]);</span></span>\n<span><span>\t\t}</span></span>\n<span><span>\t\t</span><span>printf</span><span>(</span><span>"</span><span>\\n</span><span>"</span><span>);</span></span>\n<span><span>\t}</span></span>\n<span><span>\t</span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n    </div>\n    <p>出力</p>\n    <pre><code>12 23 34 \r\n54 43 32 \r\n46 57 68 \n</code></pre>\n  </div>\n</details>\n<h2 id="user-content-発展編">発展編</h2>\n<h3 id="user-content-式文について">式、文について</h3>\n<p>式は値を返す。文は値を返さない。<code>1+1</code> は式。<code>if</code> 文や <code>switch</code> - <code>case</code>文は文だから値を返さない。<code>if</code> とか <code>switch</code> の括弧に入れられるやつは式。</p>\n<h3 id="user-content-ポインタと配列">ポインタ(と配列)</h3>\n<p>書こうと思ったけど第二回に持ち越した方がよさそうな気がしたので持ち越します。</p>\n',
  },
  {
    title: '2023年度新入部員向け講習',
    date: '2023-04-15T00:00:00.000Z',
    rootPath: 'content/blog/2023-04-newbie-training/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\n# 新入生向け講習\n\n4月に行うことが決まっていること\n\n1. C言語でオセロゲーム作成\n  - WSLなどの環境構築\n  - 1年生が1年間で学ぶC言語の知識を学ぶ\n  - [資料](blog/2023-04-newbie-training/clang)\n\n2. Git/GitHub講習\n  - Gitのインストール・設定\n  - GitHubのアカウント作成\n  - 上記C言語講習に合わせて行う\n  - [資料](/blog/2023-04-newbie-training/git)\n\n\n',
    html: '\n<h1 id="user-content-新入生向け講習">新入生向け講習</h1>\n<p>4月に行うことが決まっていること</p>\n<ol>\n  <li>C言語でオセロゲーム作成</li>\n</ol>\n<ul>\n  <li>WSLなどの環境構築</li>\n  <li>1年生が1年間で学ぶC言語の知識を学ぶ</li>\n  <li><a href="blog/2023-04-newbie-training/clang">資料</a></li>\n</ul>\n<ol start="2">\n  <li>Git/GitHub講習</li>\n</ol>\n<ul>\n  <li>Gitのインストール・設定</li>\n  <li>GitHubのアカウント作成</li>\n  <li>上記C言語講習に合わせて行う</li>\n  <li><a href="/blog/2023-04-newbie-training/git">資料</a></li>\n</ul>\n',
  },
  {
    title: 'GitHubだけでヘッドレスCMSを再現しよう！',
    date: '2023-02-19',
    description: 'GitHubだけでヘッドレスCMS(?)を再現しようとした話。',
    tags: ['dev', 'nextjs', 'jamstack'],
    author: 'okazu',
    img: 'https://user-images.githubusercontent.com/84656786/224326027-5ec479f6-893e-4820-9114-f3c47c8ab773.png',
    rootPath: 'content/blog/2023-02-github-hedless-cms/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\n\nこれはヘッドレスCMSとは呼ばないのでは…\n\n# はじめに\n\nこんにちは。農工大で1年生をやっております。\n\n2,3ヶ月前から、当サークルのホームページを一から作り直すプロジェクトを始めており、なんと、プロジェクトメンバーは僕1人(泣)\n\n今回は、ヘッドレスCMSを使いたいけど使えない事情と、その解決策(？)について書きました。\n\n# 前提\n\n- Next.js13でSSGして使う。(バックエンドなし)\n- GitHub Actionsでデプロイする。\n\n# ヘッドレスCMSとは\n\n最近のフロントエンドでは非常に良く使われています。すでに様々なサービスが存在しており、\n\n- コンテンツの保存・管理\n- コンテンツ取得用のAPIの提供(Rest, GraphQL)\n- エディタ(マークダウン, リッチテキスト)\n- GitHub Actionsのトリガー(デプロイ)\n- チーム管理(権限など)\n\nなどが機能としてあります。\n\nヘッドレスCMSがどのようなものか、詳しくは以下のサイトなどをご覧ください。\n\nhttps://blog.microcms.io/what-is-headlesscms/\n\n# ヘッドレスCMS導入への壁\n\n僕が求める要件はこんな感じ\n\n- 本体リポジトリにコミットせずに、記事を更新したい\n- 記事を更新する人の手間を増やさない(新規アカウント登録など)\n- サーバーなしで運用したい\n- できれば新しいサービスを利用せずに済ませたい\n- 無料\n\n部所有のサーバーがない、旧サイトを誰も更新しなかった、僕が下っ端なので部のアカウントを管理できない、などが理由です。\n\n最有力候補だった`Strapi`というヘッドレスCMSでさえ多くの要件を満たせません。\n\n# おっ！\n\nここで注目！ **Githubは、ブラウザからプレビュー付き簡易エディタを使えます。**\n\nまず、マークダウン置き場のリポジトリを新規作成します。こちらでは、メインブランチのみ使用し、を **「保存 = メインに直コミット」** とします。\n\nこれにより、\n\n- 部員なら**誰でも**、\n- ローカル・ブラウザ・モバイルアプリの**どの環境からでも**編集できて、\n- git関連の**面倒な手順なく**、\n- **本体のシステムを更新せず**に、\n\nCMSとして使える！！\n\n画像もアップロードできるので、画像だけは`public/`ディレクトリに置かなければならないと言う不便な点も解消されます！！\n\n# どうやってデータ取得するのさ\n\n普通、ヘッドレスCMSでブログといえば、RestやGraphQLなどの**APIをビルド時にたたき、データを取得**します。\n\nGitHubのリポジトリからデータ取得するAPIなんてあるのか？と思うかもしれませんが、簡単です。\n\n**「ビルド時にリポジトリをクローン」**\n\nすればいいんです！\n\n# 実装について\n\nまず、リポジトリを`content`ディレクトリにクローンする下記ファイルを作成します。\n\n```shell title="src/prebulid.sh"\nrm -rf content\ngit clone --depth 1 https://github.com/organization-name/CMS用gitリポジトリ.git content\n```\n\n次に、`package.json`を編集します。\n\n```diff title="package.json"\n...\n  "scripts": {\n+   "prebuild": "bash ./src/prebuild.sh",\n    "build": "next build",\n...\n```\n`npm-scripts`の機能で、`npm run build`で`build`の実行をすると、先に`prebuild`が実行されます。これで、ビルド直前にデータを取得できますね。\n\n# マークダウン変換処理\n\nメタデータの抽出に`gray-matter`、変換処理に`unified`とそのプラグインを使います。\n\n- ビルド時に、マークダウンからタイトルや日付等のメタデータを抽出した後、HTMLに変換\n- クライアント側で表示する際、HTMLからReact Componentに変換\n\n長くなるので、ここでは詳しく解説しません。\n\nこちらの記事が非常に参考になりました。\n\nhttps://www.haxibami.net/blog/posts/blog-renewal\n\nまた、Vercelが様々なテンプレートを用意しているので、それらのソースコードを見てみるのも参考になると思います。\n\n# その他小細工\n\nブラウザエディタからコピペで画像をアップロードする際は、自動的にURLを割り当ててくれるので問題ないのですが、画像ファイルを単体でアップロードし、相対パスで表示したい時もあります。\n\n例えば、webp画像はブラウザエディタでサポートされていませんし、ローカルからはそもそも自動でURLを割り当てられません。\n\nそこで、裏技的に、GitHubの`raw`表示を使います。\n\n実は、`https://raw.githubusercontent.com/organization-name/リポジトリ名/ブランチ名/該当ファイルのパス`とすることで、画像を取得できます。\n\n`utils/`ディレクトリなどにパース用関数を用意し、先ほどのHTMLからReact Componentに変換する際や、メタデータに含まれるサムネ画像URLなどを取得する際に、パース処理を挟めば完璧です！\n\n# まとめ手順\n\n1. CMS用リポジトリにてマークダウンファイルを追加・編集\n2. `main`にコミットすることで保存\n3. 本体リポジトリにて、手動でデプロイ用のGitHub Actions workflowを実行\n4. ホームページが更新\n\n# おわりに\n\n２つの別リポジトリが密結合な状態にあるのがちょっと気になりますが、今後新しくホームページを作り直すことになっても使いまわせそうなので、やっぱりこれで正解だったと思います。\n\n今後は、もっとワンポチくらいでデプロイできる仕組みを考えたいですね。サークルのDiscordサーバーにそれ用のbotを作って入れるとか…？\n\n最後に、ソースコードを貼っておきます。\n\nhttps://github.com/tuatmcc/homepage2.0\n\nhttps://github.com/tuatmcc/hp-md-content\n',
    html: '\n<p>これはヘッドレスCMSとは呼ばないのでは…</p>\n<h1 id="user-content-はじめに">はじめに</h1>\n<p>こんにちは。農工大で1年生をやっております。</p>\n<p>2,3ヶ月前から、当サークルのホームページを一から作り直すプロジェクトを始めており、なんと、プロジェクトメンバーは僕1人(泣)</p>\n<p>今回は、ヘッドレスCMSを使いたいけど使えない事情と、その解決策(？)について書きました。</p>\n<h1 id="user-content-前提">前提</h1>\n<ul>\n  <li>Next.js13でSSGして使う。(バックエンドなし)</li>\n  <li>GitHub Actionsでデプロイする。</li>\n</ul>\n<h1 id="user-content-ヘッドレスcmsとは">ヘッドレスCMSとは</h1>\n<p>最近のフロントエンドでは非常に良く使われています。すでに様々なサービスが存在しており、</p>\n<ul>\n  <li>コンテンツの保存・管理</li>\n  <li>コンテンツ取得用のAPIの提供(Rest, GraphQL)</li>\n  <li>エディタ(マークダウン, リッチテキスト)</li>\n  <li>GitHub Actionsのトリガー(デプロイ)</li>\n  <li>チーム管理(権限など)</li>\n</ul>\n<p>などが機能としてあります。</p>\n<p>ヘッドレスCMSがどのようなものか、詳しくは以下のサイトなどをご覧ください。</p>\n<p><a href="https://blog.microcms.io/what-is-headlesscms/">https://blog.microcms.io/what-is-headlesscms/</a></p>\n<h1 id="user-content-ヘッドレスcms導入への壁">ヘッドレスCMS導入への壁</h1>\n<p>僕が求める要件はこんな感じ</p>\n<ul>\n  <li>本体リポジトリにコミットせずに、記事を更新したい</li>\n  <li>記事を更新する人の手間を増やさない(新規アカウント登録など)</li>\n  <li>サーバーなしで運用したい</li>\n  <li>できれば新しいサービスを利用せずに済ませたい</li>\n  <li>無料</li>\n</ul>\n<p>部所有のサーバーがない、旧サイトを誰も更新しなかった、僕が下っ端なので部のアカウントを管理できない、などが理由です。</p>\n<p>最有力候補だった<code>Strapi</code>というヘッドレスCMSでさえ多くの要件を満たせません。</p>\n<h1 id="user-content-おっ">おっ！</h1>\n<p>ここで注目！ <strong>Githubは、ブラウザからプレビュー付き簡易エディタを使えます。</strong></p>\n<p>まず、マークダウン置き場のリポジトリを新規作成します。こちらでは、メインブランチのみ使用し、を <strong>「保存 = メインに直コミット」</strong> とします。</p>\n<p>これにより、</p>\n<ul>\n  <li>部員なら<strong>誰でも</strong>、</li>\n  <li>ローカル・ブラウザ・モバイルアプリの<strong>どの環境からでも</strong>編集できて、</li>\n  <li>git関連の<strong>面倒な手順なく</strong>、</li>\n  <li><strong>本体のシステムを更新せず</strong>に、</li>\n</ul>\n<p>CMSとして使える！！</p>\n<p>画像もアップロードできるので、画像だけは<code>public/</code>ディレクトリに置かなければならないと言う不便な点も解消されます！！</p>\n<h1 id="user-content-どうやってデータ取得するのさ">どうやってデータ取得するのさ</h1>\n<p>普通、ヘッドレスCMSでブログといえば、RestやGraphQLなどの<strong>APIをビルド時にたたき、データを取得</strong>します。</p>\n<p>GitHubのリポジトリからデータ取得するAPIなんてあるのか？と思うかもしれませんが、簡単です。</p>\n<p><strong>「ビルド時にリポジトリをクローン」</strong></p>\n<p>すればいいんです！</p>\n<h1 id="user-content-実装について">実装について</h1>\n<p>まず、リポジトリを<code>content</code>ディレクトリにクローンする下記ファイルを作成します。</p>\n<div>\n  <pre><code><span><span>rm</span><span> </span><span>-rf</span><span> </span><span>content</span></span>\n<span><span>git</span><span> </span><span>clone</span><span> </span><span>--depth</span><span> </span><span>1</span><span> </span><span>https://github.com/organization-name/CMS用gitリポジトリ.git</span><span> </span><span>content</span></span></code></pre>\n</div>\n<p>次に、<code>package.json</code>を編集します。</p>\n<div>\n  <pre><code><span><span>...</span></span>\n<span><span>  "scripts": {</span></span>\n<span><span>+   "prebuild": "bash ./src/prebuild.sh",</span></span>\n<span><span>    "build": "next build",</span></span>\n<span><span>...</span></span></code></pre>\n</div>\n<p><code>npm-scripts</code>の機能で、<code>npm run build</code>で<code>build</code>の実行をすると、先に<code>prebuild</code>が実行されます。これで、ビルド直前にデータを取得できますね。</p>\n<h1 id="user-content-マークダウン変換処理">マークダウン変換処理</h1>\n<p>メタデータの抽出に<code>gray-matter</code>、変換処理に<code>unified</code>とそのプラグインを使います。</p>\n<ul>\n  <li>ビルド時に、マークダウンからタイトルや日付等のメタデータを抽出した後、HTMLに変換</li>\n  <li>クライアント側で表示する際、HTMLからReact Componentに変換</li>\n</ul>\n<p>長くなるので、ここでは詳しく解説しません。</p>\n<p>こちらの記事が非常に参考になりました。</p>\n<p><a href="https://www.haxibami.net/blog/posts/blog-renewal">https://www.haxibami.net/blog/posts/blog-renewal</a></p>\n<p>また、Vercelが様々なテンプレートを用意しているので、それらのソースコードを見てみるのも参考になると思います。</p>\n<h1 id="user-content-その他小細工">その他小細工</h1>\n<p>ブラウザエディタからコピペで画像をアップロードする際は、自動的にURLを割り当ててくれるので問題ないのですが、画像ファイルを単体でアップロードし、相対パスで表示したい時もあります。</p>\n<p>例えば、webp画像はブラウザエディタでサポートされていませんし、ローカルからはそもそも自動でURLを割り当てられません。</p>\n<p>そこで、裏技的に、GitHubの<code>raw</code>表示を使います。</p>\n<p>実は、<code>https://raw.githubusercontent.com/organization-name/リポジトリ名/ブランチ名/該当ファイルのパス</code>とすることで、画像を取得できます。</p>\n<p><code>utils/</code>ディレクトリなどにパース用関数を用意し、先ほどのHTMLからReact Componentに変換する際や、メタデータに含まれるサムネ画像URLなどを取得する際に、パース処理を挟めば完璧です！</p>\n<h1 id="user-content-まとめ手順">まとめ手順</h1>\n<ol>\n  <li>CMS用リポジトリにてマークダウンファイルを追加・編集</li>\n  <li><code>main</code>にコミットすることで保存</li>\n  <li>本体リポジトリにて、手動でデプロイ用のGitHub Actions workflowを実行</li>\n  <li>ホームページが更新</li>\n</ol>\n<h1 id="user-content-おわりに">おわりに</h1>\n<p>２つの別リポジトリが密結合な状態にあるのがちょっと気になりますが、今後新しくホームページを作り直すことになっても使いまわせそうなので、やっぱりこれで正解だったと思います。</p>\n<p>今後は、もっとワンポチくらいでデプロイできる仕組みを考えたいですね。サークルのDiscordサーバーにそれ用のbotを作って入れるとか…？</p>\n<p>最後に、ソースコードを貼っておきます。</p>\n<p><a href="https://github.com/tuatmcc/homepage2.0">https://github.com/tuatmcc/homepage2.0</a></p>\n<p><a href="https://github.com/tuatmcc/hp-md-content">https://github.com/tuatmcc/hp-md-content</a></p>\n',
  },
  {
    title: 'Arch Linuxで学内LAN(tuatnet)に接続する',
    date: '2023-01-07',
    tags: ['btw'],
    author: 'vm-xeck',
    rootPath: 'content/blog/2023-01-arch-tuatnet/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\n## 概要\n\nArch Linux で，wpa_supplicant と systemd を用いて tuatnet に接続する方法を説明します\n\n## 対象\n\nArch ｲﾝｽｺしたけど tuatnet に繋がらないよーって人\n\n一応おうち Wi-Fi に無線で接続するところからやります\n\n## 準備\n\n### [情報なんとかセンターのサイト](https://www.imc.tuat.ac.jp/info-system0/campusnet/wlan/index.html)で tuatnet について学ぶ\n\n802.1x とか PEAP/MSCHAPv2 とか書いてあります\n\n### 必要なパッケージを用意する\n\nみんな大好き Pacman を駆使してかき集めます\n\n- systemd は入ってるはずなのでそのまま\n- wpa_supplicant をインストール\n  - 任意で wpa_supplicant_gui(AUR)もインストール\n- iwd が入ってる場合はアンインストール\n- NetworkManager 系が入ってる場合はアンインストール\n  - 無効化だけでもいいです\n  - systemd の替わりに NM を使うこともできますが，ここでは解説しません\n\n## 知識？\n\n私は初心者なので詳しいことは割愛させて頂きます．\n詳しく知りたい方は[この](https://wiki.archlinux.jp/index.php/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E8%A8%AD%E5%AE%9A)[へん](https://wiki.archlinux.jp/index.php/%E3%83%AF%E3%82%A4%E3%83%A4%E3%83%AC%E3%82%B9%E8%A8%AD%E5%AE%9A)を見ると良いんじゃないでしょうか\n\nとにかく，tuatnet に接続するには DHCP クライアントと DNS クライアントが必要です．\n先程用意したパッケージのうち，systemd には[systemd-networkd](https://wiki.archlinux.jp/index.php/Systemd-networkd)と[systemd-resolved](https://wiki.archlinux.jp/index.php/Systemd-resolved)が含まれます．\nsystemd-networkd はネットワーク設定を管理し，内蔵 DHCP クライアントを提供します．\nsystemd-resolved は DNS クライアントの役割を果たします．\nこれらだけでも有線接続は可能ですが，無線で接続するために[wpa_supplicant](https://wiki.archlinux.jp/index.php/Wpa_supplicant)が必要です．\n\n各ソフトウェアについて詳しく知りたい方は，リンク先の Arch Wiki を読むのがおすすめです．\n記事で無線ネットワークインターフェイスという語が登場しますが，\nこれは無線接続に使用されるネットワークカードのことです．\n次のコマンドを使用することで名前を確認できます(たぶん wl から始まるやつです)．\n\n```bash\n$ ip link\n```\n\n私のは wlp2s0 でした(隙自語)\n\n## 設定\n\n### まず，systemd-networkd を設定して DHCP を有効にします．\n\n`/etc/systemd/network/25-wireless.network`を編集し，次のように書きます．\n**以下，`wlp2s0`は自分の無線ネットワークインターフェイス名に置き換えてください．**\nArch Wiki でいうと[ここ](https://wiki.archlinux.jp/index.php/Systemd-networkd#.E7.84.A1.E7.B7.9A.E3.82.A2.E3.83.80.E3.83.97.E3.82.BF)です．\n\n```systemd title="25-wireless.network"\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=yes\n```\n\nsystemd-networkd を起動と同時に有効化(電源を入れた時自動で起動するように設定)します．\n次のコマンドを使用します．\n\n```bash\n$ sudo systemctl enable --now systemd-networkd\n```\n\n### 次に wpa_supplicant を設定します．\n\n[当該記事](https://wiki.archlinux.jp/index.php/Wpa_supplicant#wpa_cli_.E3.81.A7.E6.8E.A5.E7.B6.9A.E3.81.99.E3.82.8B)を見ながらやっていきましょう．\n接続には wpa_cli を使用します(他のでもいいと思います)．\n`/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf`を編集し，次のように書きます．\n\n```systemd title="wpa_supplicant-wlp2s0.conf"\nctrl_interface=/run/wpa_supplicant\nupdate_config=1\n```\n\n次のコマンドで wpa_supplicant を起動します．\n\n```bash\n$ sudo wpa_supplicant -B -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf\n```\n\nいよいよ接続します！\nまずはおうちの Wi-Fi で試してみましょう．\n\n```bash\n$ sudo wpa_cli\n```\n\nプロンプトが現れるので操作していきます．スラッシュ以降はコメントなので打たないでください．\n\n```\n> scan  // ネットワークをスキャンします\n\n> scan_results  // スキャン結果を表示します　接続したいネットワークを探しましょう\n\n> add_network   // ネットワークを追加します\n                // 以降，ここで「0」と表示されたとして話を進めますが，\n                // 別の数字が表示された場合はその数字を使ってください\n\n> set_network 0 ssid "YOURSSID"  // YOURSSIDをSSIDで置き換えます\n> set_network 0 psk "passphrase"  // passphraseをパスワードで置き換えます\n\n> enable_network 0\n\n> save_config\n```\n\nこれで`/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf`に設定が保存されているはずです．\n\n`/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf`に tuatnet 用の設定を追加しましょう．\n次の内容を追記します．\nArch Wiki の[この部分](https://wiki.archlinux.jp/index.php/Wpa_supplicant#802.1x.2Fradius)です．\n\n```systemd title="wpa_supplicant-wlp2s0.conf"\nnetwork={\n    ssid="tuatnet"\n    key_mgmt=WPA-EAP\n    eap=PEAP\n    identity="user_name"\n    password="user_password"\n    phase2="autheap=MSCHAPV2"\n}\n```\n\nuser_name をあなたの TUAT-ID，user_password をあなたの TUAT-ID 用パスワードに置き換えます．\nnetwork ブロックが複数になっていますが，これで大丈夫です．\n\n大事なパスワードが書いてあるファイルなので，念のため閲覧権限を絞っておきましょう．\n次のコマンドを使います．\n\n```bash\n$ sudo chmod 600 /etc/wpa_supplicant/wpausupplicant-wlp2s0.conf\n```\n\nそれから忘れずに wpa_supplicant のデーモンを起動・有効化しましょう．\nインターフェイス名は置き換えてください(定期)\n\n```bash\n$ sudo systemctl enable --now wpa_supplicant@wlp2s0\n```\n\n### 最後に systemd-resolved を起動します．\n\n今回のような単純な目的では特に設定は必要なく，次のコマンドを使用するだけです．\n\n```bash\n$ sudo systemctl enable --now systemd-resolved\n```\n\n終わりです．お疲れさまでした！\n\n## 終わりに\n\n本記事を書くにあたって，学外の[しゅどぼ](https://twitter.com/_QiToY)に協力してもらいました．\n感謝申し上げます\n\nなお，本記事は初心者が書いているので，間違いなどを見つけたらボコボコにしてください．\n訂正，質問，その他何でも[筆者 Twitter](https://twitter.com/vm_xeck)までお寄せください(ダイマ)\n',
    html: '\n<h2 id="user-content-概要">概要</h2>\n<p>Arch Linux で，wpa_supplicant と systemd を用いて tuatnet に接続する方法を説明します</p>\n<h2 id="user-content-対象">対象</h2>\n<p>Arch ｲﾝｽｺしたけど tuatnet に繋がらないよーって人</p>\n<p>一応おうち Wi-Fi に無線で接続するところからやります</p>\n<h2 id="user-content-準備">準備</h2>\n<h3 id="user-content-情報なんとかセンターのサイトで-tuatnet-について学ぶ"><a href="https://www.imc.tuat.ac.jp/info-system0/campusnet/wlan/index.html">情報なんとかセンターのサイト</a>で tuatnet について学ぶ</h3>\n<p>802.1x とか PEAP/MSCHAPv2 とか書いてあります</p>\n<h3 id="user-content-必要なパッケージを用意する">必要なパッケージを用意する</h3>\n<p>みんな大好き Pacman を駆使してかき集めます</p>\n<ul>\n  <li>systemd は入ってるはずなのでそのまま</li>\n  <li>wpa_supplicant をインストール\n    <ul>\n      <li>任意で wpa_supplicant_gui(AUR)もインストール</li>\n    </ul>\n  </li>\n  <li>iwd が入ってる場合はアンインストール</li>\n  <li>NetworkManager 系が入ってる場合はアンインストール\n    <ul>\n      <li>無効化だけでもいいです</li>\n      <li>systemd の替わりに NM を使うこともできますが，ここでは解説しません</li>\n    </ul>\n  </li>\n</ul>\n<h2 id="user-content-知識">知識？</h2>\n<p>\n  私は初心者なので詳しいことは割愛させて頂きます．\n  詳しく知りたい方は<a href="https://wiki.archlinux.jp/index.php/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E8%A8%AD%E5%AE%9A">この</a><a href="https://wiki.archlinux.jp/index.php/%E3%83%AF%E3%82%A4%E3%83%A4%E3%83%AC%E3%82%B9%E8%A8%AD%E5%AE%9A">へん</a>を見ると良いんじゃないでしょうか\n</p>\n<p>\n  とにかく，tuatnet に接続するには DHCP クライアントと DNS クライアントが必要です．\n  先程用意したパッケージのうち，systemd には<a href="https://wiki.archlinux.jp/index.php/Systemd-networkd">systemd-networkd</a>と<a href="https://wiki.archlinux.jp/index.php/Systemd-resolved">systemd-resolved</a>が含まれます．\n  systemd-networkd はネットワーク設定を管理し，内蔵 DHCP クライアントを提供します．\n  systemd-resolved は DNS クライアントの役割を果たします．\n  これらだけでも有線接続は可能ですが，無線で接続するために<a href="https://wiki.archlinux.jp/index.php/Wpa_supplicant">wpa_supplicant</a>が必要です．\n</p>\n<p>\n  各ソフトウェアについて詳しく知りたい方は，リンク先の Arch Wiki を読むのがおすすめです．\n  記事で無線ネットワークインターフェイスという語が登場しますが，\n  これは無線接続に使用されるネットワークカードのことです．\n  次のコマンドを使用することで名前を確認できます(たぶん wl から始まるやつです)．\n</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>ip</span><span> </span><span>link</span></span></code></pre>\n</div>\n<p>私のは wlp2s0 でした(隙自語)</p>\n<h2 id="user-content-設定">設定</h2>\n<h3 id="user-content-まずsystemd-networkd-を設定して-dhcp-を有効にします">まず，systemd-networkd を設定して DHCP を有効にします．</h3>\n<p>\n  <code>/etc/systemd/network/25-wireless.network</code>を編集し，次のように書きます．\n  <strong>以下，<code>wlp2s0</code>は自分の無線ネットワークインターフェイス名に置き換えてください．</strong>\n  Arch Wiki でいうと<a href="https://wiki.archlinux.jp/index.php/Systemd-networkd#.E7.84.A1.E7.B7.9A.E3.82.A2.E3.83.80.E3.83.97.E3.82.BF">ここ</a>です．\n</p>\n<div>\n  <pre><code><span><span>[Match]</span></span>\n<span><span>Name=wlp2s0</span></span>\n<span><span></span></span>\n<span><span>[Network]</span></span>\n<span><span>DHCP=yes</span></span></code></pre>\n</div>\n<p>\n  systemd-networkd を起動と同時に有効化(電源を入れた時自動で起動するように設定)します．\n  次のコマンドを使用します．\n</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>sudo</span><span> </span><span>systemctl</span><span> </span><span>enable</span><span> </span><span>--now</span><span> </span><span>systemd-networkd</span></span></code></pre>\n</div>\n<h3 id="user-content-次に-wpa_supplicant-を設定します">次に wpa_supplicant を設定します．</h3>\n<p>\n  <a href="https://wiki.archlinux.jp/index.php/Wpa_supplicant#wpa_cli_.E3.81.A7.E6.8E.A5.E7.B6.9A.E3.81.99.E3.82.8B">当該記事</a>を見ながらやっていきましょう．\n  接続には wpa_cli を使用します(他のでもいいと思います)．\n  <code>/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf</code>を編集し，次のように書きます．\n</p>\n<div>\n  <pre><code><span><span>ctrl_interface=/run/wpa_supplicant</span></span>\n<span><span>update_config=1</span></span></code></pre>\n</div>\n<p>次のコマンドで wpa_supplicant を起動します．</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>sudo</span><span> </span><span>wpa_supplicant</span><span> </span><span>-B</span><span> </span><span>-i</span><span> </span><span>wlp2s0</span><span> </span><span>-c</span><span> </span><span>/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf</span></span></code></pre>\n</div>\n<p>\n  いよいよ接続します！\n  まずはおうちの Wi-Fi で試してみましょう．\n</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>sudo</span><span> </span><span>wpa_cli</span></span></code></pre>\n</div>\n<p>プロンプトが現れるので操作していきます．スラッシュ以降はコメントなので打たないでください．</p>\n<pre><code>> scan  // ネットワークをスキャンします\n\n> scan_results  // スキャン結果を表示します　接続したいネットワークを探しましょう\n\n> add_network   // ネットワークを追加します\n                // 以降，ここで「0」と表示されたとして話を進めますが，\n                // 別の数字が表示された場合はその数字を使ってください\n\n> set_network 0 ssid "YOURSSID"  // YOURSSIDをSSIDで置き換えます\n> set_network 0 psk "passphrase"  // passphraseをパスワードで置き換えます\n\n> enable_network 0\n\n> save_config\n</code></pre>\n<p>これで<code>/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf</code>に設定が保存されているはずです．</p>\n<p>\n  <code>/etc/wpa_supplicant/wpa_supplicant-wlp2s0.conf</code>に tuatnet 用の設定を追加しましょう．\n  次の内容を追記します．\n  Arch Wiki の<a href="https://wiki.archlinux.jp/index.php/Wpa_supplicant#802.1x.2Fradius">この部分</a>です．\n</p>\n<div>\n  <pre><code><span><span>network={</span></span>\n<span><span>    ssid="tuatnet"</span></span>\n<span><span>    key_mgmt=WPA-EAP</span></span>\n<span><span>    eap=PEAP</span></span>\n<span><span>    identity="user_name"</span></span>\n<span><span>    password="user_password"</span></span>\n<span><span>    phase2="autheap=MSCHAPV2"</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>\n  user_name をあなたの TUAT-ID，user_password をあなたの TUAT-ID 用パスワードに置き換えます．\n  network ブロックが複数になっていますが，これで大丈夫です．\n</p>\n<p>\n  大事なパスワードが書いてあるファイルなので，念のため閲覧権限を絞っておきましょう．\n  次のコマンドを使います．\n</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>sudo</span><span> </span><span>chmod</span><span> </span><span>600</span><span> </span><span>/etc/wpa_supplicant/wpausupplicant-wlp2s0.conf</span></span></code></pre>\n</div>\n<p>\n  それから忘れずに wpa_supplicant のデーモンを起動・有効化しましょう．\n  インターフェイス名は置き換えてください(定期)\n</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>sudo</span><span> </span><span>systemctl</span><span> </span><span>enable</span><span> </span><span>--now</span><span> </span><span>wpa_supplicant@wlp2s0</span></span></code></pre>\n</div>\n<h3 id="user-content-最後に-systemd-resolved-を起動します">最後に systemd-resolved を起動します．</h3>\n<p>今回のような単純な目的では特に設定は必要なく，次のコマンドを使用するだけです．</p>\n<div>\n  <pre><code><span><span>$</span><span> </span><span>sudo</span><span> </span><span>systemctl</span><span> </span><span>enable</span><span> </span><span>--now</span><span> </span><span>systemd-resolved</span></span></code></pre>\n</div>\n<p>終わりです．お疲れさまでした！</p>\n<h2 id="user-content-終わりに">終わりに</h2>\n<p>\n  本記事を書くにあたって，学外の<a href="https://twitter.com/_QiToY">しゅどぼ</a>に協力してもらいました．\n  感謝申し上げます\n</p>\n<p>\n  なお，本記事は初心者が書いているので，間違いなどを見つけたらボコボコにしてください．\n  訂正，質問，その他何でも<a href="https://twitter.com/vm_xeck">筆者 Twitter</a>までお寄せください(ダイマ)\n</p>\n',
  },
  {
    title: '記事の書き方',
    description: 'Markdown記事をホームページに追加する方法を説明します。',
    date: '2023-01-05',
    tags: ['web', 'dev'],
    author: 'ojii3',
    img: 'https://user-images.githubusercontent.com/84656786/219551946-1b80cbaa-7e2f-47be-a99c-ed9a1a615947.png',
    rootPath: 'content/blog/2023-01-adding-articles/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\n# 手順\n\n<https://github.com/tuatmcc/hp-md-content> を更新することがメイン工程となります。\n\nここから先は、ブラウザからの操作を想定して説明します。クローンしたローカル環境や、スマホアプリ上でも手順は大きくは変わりません。(スマホアプリ上からは一部機能が使えませんので、最終的にはブラウザが必要です)\n\nMCC からのお知らせ記事(活動報告も含む)は、`news`フォルダに、それ以外(技術記事・ポエムなど)は`blog`フォルダにおきます。\n\n例えば、「ホームページリニューアル」というお知らせ記事を作成する手順は以下のようになります。\n\n1. <https://github.com/tuatmcc/hp-md-content> にアクセスし、`news`フォルダに進みます。\n2. ページ右上の`Creat new file`を押すと、ブラウザ上で簡易エディタが開くので、ファイル名を`homepage-renewal/index.md`などとして下さい。 **スラッシュ/以降は必ず`index.md`です**\n3. マークダウンで記事を書きます。その際の書き方は後ほど述べます。\n4. `main`ブランチに`commit`して保存します。\n5. 次の正午までにホームページに更新が反映されます。\n\n※ 逆に、ファイル名を、`_index.md`などとして保存することで、下書き状態を作れます。\n\n## 注意事項\n\n記事の先頭に以下のような記述が必要です。\n\n```markdown title="blog/bocchi-the-rock/index.md"\n---\ntitle: "ぼっち・ざ・ろっくを鑑賞しました"\ndescription: "ぼっち・ざ・ろっくをみた"\nimg: "./bocchi-the-rock.webp"\ndate: "2023-01-03"\ntags: [dev, web, nextjs]\nauthor: "Goto Hitori"\n---\n```\n\n`title`は必須です。`date`も記事並べ替えのために書いてください。\n\nまた、画像の URL は、同じフォルダに画像をアップロードし、`./画像のファイル名`とするか、`httpsから始まる外部URL`でお願いします。\n\nなお、ブラウザ上から編集する際は、ドラッグ&ドロップで簡単に画像を置くことができます。\n\n(前者の相対パスの方法を推進)\n\n```markdown\n![alt text](./bocchi.webp)\n```\n\n![alt text](./bocchi.webp)\n\n```markdown\n![logo](https://user-images.githubusercontent.com/84656786/224228583-2f400e96-e64a-4322-9c87-9c0066c43f8f.svg)\n```\n\n![logo](https://user-images.githubusercontent.com/84656786/224228583-2f400e96-e64a-4322-9c87-9c0066c43f8f.svg)\n\n# マークダウンの書き方\n\nマークダウンの書き方を紹介します。基本文法は同じですが、所々他のブログサービスと相違があります。\n\n## 見出し\n\n見出しの右にはリンクがつきます。目次(未実装)とか、ページ内リンクに対応できます。\n\n```markdown\n# これは h1 の見出しです\n\n## これは h2 の見出しです\n\n### h3~は文字サイズが徐々に小さくなるだけです。h6 まで\n```\n\n# これは h1 の見出しです\n\n## これは h2 の見出しです\n\n### h3~は文字サイズが徐々に小さくなるだけです。h6 まで\n\n## リスト\n\n箇条書きには`-`, `+`, `*`などが使えます。箇条書きの方はネストできます。\n\n```markdown\n- リスト１\n- リスト２\n  - リスト 2-1\n  - リスト 2-2\n\n1. 番号付きリスト 1\n2. 番号付きリスト 2\n```\n\n- リスト１\n- リスト２\n  - リスト 2-1\n  - リスト 2-2\n\n1. 番号付きリスト 1\n2. 番号付きリスト 2\n\n## チェックボックス\n\n```markdown\n- [ ] チェックボックス 1\n- [x] チェックボックス 2\n```\n\n- [ ] チェックボックス 1\n- [x] チェックボックス 2\n\n## 斜体・強調・打消し\n\n`*`,`**`は`_`,`__`と置き換えられます\n\n```markdown\n_Italic 斜体です_\n\n**強調**\n\n~~打消し線（css の装飾）~~\n```\n\n_Italic 斜体_\n\n**強調**\n\n~~打消し線（css の装飾）~~\n\n## リンク\n\n```markdown\n[外部リンク](https://www.google.com)\n\n[内部リンク](/gallery)\n\n生のリンク: <https://google.com>\n```\n\n[外部リンク](https://www.google.com)\n\n[内部リンク](/gallery)\n\n生のリンク: <https://google.com>\n\n## 画像\n\n```markdown\n外部 URL\n![画像](https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png)\n\n内部 URL (相対パス)\n![bocchi](./bocchi.webp)\n```\n\n外部 URL\n![画像](https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png)\n\n内部 URL (相対パス)\n![bocchi](./bocchi.webp)\n\n## 折りたたみ\n\n```markdown\n<details>\n<summary>折りたたみ</summary>\n\n折りたたみの中身です\n\n</details>\n```\n\n<details>\n<summary>折りたたみ</summary>\n\n折りたたみの中身です\n\n</details>\n\n## 脚注\n\n```markdown\n脚注[^1]\n\n[^1]: 脚注です\n```\n\n脚注[^1]\n\n[^1]: 脚注です\n\n## 表\n\n```markdown\n| title        | date | tags     |\n| ------------ | ---- | -------- |\n| こんにちは   | 2022 | web, dev |\n| これは表です | 2022 | web, dev |\n```\n\n| title        | date | tags     |\n| ------------ | ---- | -------- |\n| こんにちは   | 2022 | web, dev |\n| これは表です | 2022 | web, dev |\n\n## 引用\n\n```markdown\n> 引用です。\n>\n> > 引用の中の引用です。\n>\n> That\'s all.\n```\n\n> 引用です。\n>\n> > 引用の中の引用です。\n>\n> That\'s all.\n\n## インラインコード\n\n```markdown\n`これはインラインコードです` `Font は JetBrains Monoを使用` `` コード内で"`"を使うには、"`"を一個追加してはさみます ``\n```\n\n`これはインラインコードです` `Font は JetBrains Monoを使用` `` コード内で"`"を使うには、"`"を一個追加してはさみます ``\n\n## コードブロック\n\nタイトル(ファイル名)はあってもなくてもいけます。タイトルのみ書くことはできません。\n\n````markdown title="markdown"\n```python title="blog.py"\nprint(\'Hello World\')\n```\n`````\n\n```python title="blog.py"\nprint(\'Hello World\')\n```\n\n````markdown title="markdown"\n```diff\n- これは削除です\n+ これは追加です\n```\n````\n\n```diff\n- これは削除です\n+ これは追加です\n```\n\n## 数式\n\nKaTex を使用しています。\n\n```math\n$$\nL = \\frac{1}{2} \\rho v^2 S C_L\n$$\n```\n\n$$\nL = \\frac{1}{2} \\rho v^2 S C_L\n$$\n\n## emoji\n\n```markdown\n:smile: :+1: :tada: :rocket: :metal:\n```\n\n:smile: :+1: :tada: :rocket: :metal:\n\n```\n\n```\n',
    html: '\n<h1 id="user-content-手順">手順</h1>\n<p><a href="https://github.com/tuatmcc/hp-md-content">https://github.com/tuatmcc/hp-md-content</a> を更新することがメイン工程となります。</p>\n<p>ここから先は、ブラウザからの操作を想定して説明します。クローンしたローカル環境や、スマホアプリ上でも手順は大きくは変わりません。(スマホアプリ上からは一部機能が使えませんので、最終的にはブラウザが必要です)</p>\n<p>MCC からのお知らせ記事(活動報告も含む)は、<code>news</code>フォルダに、それ以外(技術記事・ポエムなど)は<code>blog</code>フォルダにおきます。</p>\n<p>例えば、「ホームページリニューアル」というお知らせ記事を作成する手順は以下のようになります。</p>\n<ol>\n  <li><a href="https://github.com/tuatmcc/hp-md-content">https://github.com/tuatmcc/hp-md-content</a> にアクセスし、<code>news</code>フォルダに進みます。</li>\n  <li>ページ右上の<code>Creat new file</code>を押すと、ブラウザ上で簡易エディタが開くので、ファイル名を<code>homepage-renewal/index.md</code>などとして下さい。 <strong>スラッシュ/以降は必ず<code>index.md</code>です</strong></li>\n  <li>マークダウンで記事を書きます。その際の書き方は後ほど述べます。</li>\n  <li><code>main</code>ブランチに<code>commit</code>して保存します。</li>\n  <li>次の正午までにホームページに更新が反映されます。</li>\n</ol>\n<p>※ 逆に、ファイル名を、<code>_index.md</code>などとして保存することで、下書き状態を作れます。</p>\n<h2 id="user-content-注意事項">注意事項</h2>\n<p>記事の先頭に以下のような記述が必要です。</p>\n<div>\n  <pre><code><span><span>---</span></span>\n<span><span>title</span><span>: </span><span>"ぼっち・ざ・ろっくを鑑賞しました"</span></span>\n<span><span>description</span><span>: </span><span>"ぼっち・ざ・ろっくをみた"</span></span>\n<span><span>img</span><span>: </span><span>"./bocchi-the-rock.webp"</span></span>\n<span><span>date</span><span>: </span><span>"2023-01-03"</span></span>\n<span><span>tags</span><span>: [</span><span>dev</span><span>, </span><span>web</span><span>, </span><span>nextjs</span><span>]</span></span>\n<span><span>author</span><span>: </span><span>"Goto Hitori"</span></span>\n<span><span>---</span></span></code></pre>\n</div>\n<p><code>title</code>は必須です。<code>date</code>も記事並べ替えのために書いてください。</p>\n<p>また、画像の URL は、同じフォルダに画像をアップロードし、<code>./画像のファイル名</code>とするか、<code>httpsから始まる外部URL</code>でお願いします。</p>\n<p>なお、ブラウザ上から編集する際は、ドラッグ&#x26;ドロップで簡単に画像を置くことができます。</p>\n<p>(前者の相対パスの方法を推進)</p>\n<div>\n  <pre><code><span><span>![</span><span>alt text</span><span>](</span><span>./bocchi.webp</span><span>)</span></span></code></pre>\n</div>\n<p>\n  <img src="./bocchi.webp" alt="alt text">\n</p>\n<div>\n  <pre><code><span><span>![</span><span>logo</span><span>](</span><span>https://user-images.githubusercontent.com/84656786/224228583-2f400e96-e64a-4322-9c87-9c0066c43f8f.svg</span><span>)</span></span></code></pre>\n</div>\n<p>\n  <img src="https://user-images.githubusercontent.com/84656786/224228583-2f400e96-e64a-4322-9c87-9c0066c43f8f.svg" alt="logo">\n</p>\n<h1 id="user-content-マークダウンの書き方">マークダウンの書き方</h1>\n<p>マークダウンの書き方を紹介します。基本文法は同じですが、所々他のブログサービスと相違があります。</p>\n<h2 id="user-content-見出し">見出し</h2>\n<p>見出しの右にはリンクがつきます。目次(未実装)とか、ページ内リンクに対応できます。</p>\n<div>\n  <pre><code><span><span># これは h1 の見出しです</span></span>\n<span> </span>\n<span><span>## これは h2 の見出しです</span></span>\n<span> </span>\n<span><span>### h3~は文字サイズが徐々に小さくなるだけです。h6 まで</span></span></code></pre>\n</div>\n<h1 id="user-content-これは-h1-の見出しです">これは h1 の見出しです</h1>\n<h2 id="user-content-これは-h2-の見出しです">これは h2 の見出しです</h2>\n<h3 id="user-content-h3は文字サイズが徐々に小さくなるだけですh6-まで">h3~は文字サイズが徐々に小さくなるだけです。h6 まで</h3>\n<h2 id="user-content-リスト">リスト</h2>\n<p>箇条書きには<code>-</code>, <code>+</code>, <code>*</code>などが使えます。箇条書きの方はネストできます。</p>\n<div>\n  <pre><code><span><span>-</span><span> リスト１</span></span>\n<span><span>-</span><span> リスト２</span></span>\n<span><span>  </span><span>-</span><span> リスト 2-1</span></span>\n<span><span>  </span><span>-</span><span> リスト 2-2</span></span>\n<span> </span>\n<span><span>1.</span><span> 番号付きリスト 1</span></span>\n<span><span>2.</span><span> 番号付きリスト 2</span></span></code></pre>\n</div>\n<ul>\n  <li>リスト１</li>\n  <li>リスト２\n    <ul>\n      <li>リスト 2-1</li>\n      <li>リスト 2-2</li>\n    </ul>\n  </li>\n</ul>\n<ol>\n  <li>番号付きリスト 1</li>\n  <li>番号付きリスト 2</li>\n</ol>\n<h2 id="user-content-チェックボックス">チェックボックス</h2>\n<div>\n  <pre><code><span><span>-</span><span> [ ] チェックボックス 1</span></span>\n<span><span>-</span><span> [</span><span>x</span><span>] チェックボックス 2</span></span></code></pre>\n</div>\n<ul>\n  <li class="task-list-item"><input type="checkbox" disabled> チェックボックス 1</li>\n  <li class="task-list-item"><input type="checkbox" checked disabled> チェックボックス 2</li>\n</ul>\n<h2 id="user-content-斜体強調打消し">斜体・強調・打消し</h2>\n<p><code>*</code>,<code>**</code>は<code>_</code>,<code>__</code>と置き換えられます</p>\n<div>\n  <pre><code><span><span>_Italic 斜体です_</span></span>\n<span> </span>\n<span><span>**強調**</span></span>\n<span> </span>\n<span><span>~~打消し線（css の装飾）~~</span></span></code></pre>\n</div>\n<p><em>Italic 斜体</em></p>\n<p><strong>強調</strong></p>\n<p><del>打消し線（css の装飾）</del></p>\n<h2 id="user-content-リンク">リンク</h2>\n<div>\n  <pre><code><span><span>[</span><span>外部リンク</span><span>](</span><span>https://www.google.com</span><span>)</span></span>\n<span> </span>\n<span><span>[</span><span>内部リンク</span><span>](</span><span>/gallery</span><span>)</span></span>\n<span> </span>\n<span><span>生のリンク: &#x3C;</span><span>https://google.com</span><span>></span></span></code></pre>\n</div>\n<p><a href="https://www.google.com">外部リンク</a></p>\n<p><a href="/gallery">内部リンク</a></p>\n<p>生のリンク: <a href="https://google.com">https://google.com</a></p>\n<h2 id="user-content-画像">画像</h2>\n<div>\n  <pre><code><span><span>外部 URL</span></span>\n<span><span>![</span><span>画像</span><span>](</span><span>https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png</span><span>)</span></span>\n<span> </span>\n<span><span>内部 URL (相対パス)</span></span>\n<span><span>![</span><span>bocchi</span><span>](</span><span>./bocchi.webp</span><span>)</span></span></code></pre>\n</div>\n<p>\n  外部 URL\n  \n  <img src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" alt="画像">\n</p>\n<p>\n  内部 URL (相対パス)\n  \n  <img src="./bocchi.webp" alt="bocchi">\n</p>\n<h2 id="user-content-折りたたみ">折りたたみ</h2>\n<div>\n  <pre><code><span><span>&#x3C;details></span></span>\n<span><span>&#x3C;summary>折りたたみ&#x3C;/summary></span></span>\n<span> </span>\n<span><span>折りたたみの中身です</span></span>\n<span> </span>\n<span><span>&#x3C;/details></span></span></code></pre>\n</div>\n<details>\n  <summary>折りたたみ</summary>\n  <p>折りたたみの中身です</p>\n</details>\n<h2 id="user-content-脚注">脚注</h2>\n<div>\n  <pre><code><span><span>脚注[</span><span>^1</span><span>]</span></span>\n<span> </span>\n<span><span>[</span><span>^1</span><span>]: </span><span>脚注です</span></span></code></pre>\n</div>\n<p>脚注<sup><a href="#user-content-fn-1" id="user-content-user-content-fnref-1" aria-describedby="footnote-label">1</a></sup></p>\n<h2 id="user-content-表">表</h2>\n<div>\n  <pre><code><span><span>| title        | date | tags     |</span></span>\n<span><span>| ------------ | ---- | -------- |</span></span>\n<span><span>| こんにちは   | 2022 | web, dev |</span></span>\n<span><span>| これは表です | 2022 | web, dev |</span></span></code></pre>\n</div>\n<table>\n  <thead>\n    <tr>\n      <th>title</th>\n      <th>date</th>\n      <th>tags</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>こんにちは</td>\n      <td>2022</td>\n      <td>web, dev</td>\n    </tr>\n    <tr>\n      <td>これは表です</td>\n      <td>2022</td>\n      <td>web, dev</td>\n    </tr>\n  </tbody>\n</table>\n<h2 id="user-content-引用">引用</h2>\n<div>\n  <pre><code><span><span>> 引用です。</span></span>\n<span><span>></span></span>\n<span><span>> > 引用の中の引用です。</span></span>\n<span><span>></span></span>\n<span><span>> That\'s all.</span></span></code></pre>\n</div>\n<blockquote>\n  <p>引用です。</p>\n  <blockquote>\n    <p>引用の中の引用です。</p>\n  </blockquote>\n  <p>That\'s all.</p>\n</blockquote>\n<h2 id="user-content-インラインコード">インラインコード</h2>\n<div>\n  <pre><code><span><span>`これはインラインコードです`</span><span> </span><span>`Font は JetBrains Monoを使用`</span><span> </span><span>`` コード内で"`"を使うには、"`"を一個追加してはさみます ``</span></span></code></pre>\n</div>\n<p><code>これはインラインコードです</code> <code>Font は JetBrains Monoを使用</code> <code>コード内で"`"を使うには、"`"を一個追加してはさみます</code></p>\n<h2 id="user-content-コードブロック">コードブロック</h2>\n<p>タイトル(ファイル名)はあってもなくてもいけます。タイトルのみ書くことはできません。</p>\n<div>\n  <pre><code><span><span>```python title="blog.py"</span></span>\n<span><span>print</span><span>(</span><span>\'Hello World\'</span><span>)</span></span>\n<span><span>```</span></span></code></pre>\n</div>\n<div>\n  <pre><code><span><span>print</span><span>(</span><span>\'Hello World\'</span><span>)</span></span></code></pre>\n</div>\n<div>\n  <pre><code><span><span>```diff</span></span>\n<span><span>- これは削除です</span></span>\n<span><span>+ これは追加です</span></span>\n<span><span>```</span></span></code></pre>\n</div>\n<div>\n  <pre><code><span><span>- これは削除です</span></span>\n<span><span>+ これは追加です</span></span></code></pre>\n</div>\n<h2 id="user-content-数式">数式</h2>\n<p>KaTex を使用しています。</p>\n<div>\n  <pre><code><span><span>$$</span></span>\n<span><span>L = \\frac{1}{2} \\rho v^2 S C_L</span></span>\n<span><span>$$</span></span></code></pre>\n</div>\n<div><span><span><span>L=12ρv2SCLL = \\frac{1}{2} \\rho v^2 S C_L</span><span aria-hidden="true"><span><span></span><span>L</span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span>ρ</span><span><span>v</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span>S</span><span><span>C</span><span><span><span><span><span><span></span><span><span>L</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></div>\n<h2 id="user-content-emoji">emoji</h2>\n<div>\n  <pre><code><span><span>:smile: :+1: :tada: :rocket: :metal:</span></span></code></pre>\n</div>\n<p>😄 👍 🎉 🚀 🤘</p>\n<pre><code></code></pre>\n<h2 id="user-content-footnote-label">Footnotes</h2>\n<ol>\n  <li id="user-content-user-content-fn-1">\n    <p>脚注です <a href="#user-content-fnref-1" aria-label="Back to content">↩</a></p>\n  </li>\n</ol>\n',
  },
  {
    title: 'Discord Bot チュートリアル',
    description: 'Discord Bot の開発チュートリアルを行いました。',
    date: '2022-03-16',
    tags: ['dev'],
    img: '/abstract-tech-image-1.webp',
    rootPath: 'content/blog/2022-03-discord-bot-tutorial/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\r\n# Discord Bot チュートリアル\r\n\r\nこんにちは。B3 の Arc です。2022 年 2 月 18 日に部内で Discord Bot の開発チュートリアルを行いました。当時の資料を元に加筆・修正を加えた物を公開してみます。\r\n\r\n# 近頃の Discord Bot 界隈\r\n\r\n最初に、近頃の Discord Bot 開発者界隈を取り巻く状況について軽く触れておきます。\r\n\r\n## むかし\r\n\r\n昔は Bot 開発用の 2 大ライブラリとして、Python 用の[discord.py](https://discordpy.readthedocs.io/en/latest/)と Node.js 用の[discord.js](https://discord.js.org/)がありました。\r\n\r\n## 2021 年 8 月 28 日\r\n\r\nこの日に discord.py の開発終了が[アナウンスされました](https://gist.github.com/Rapptz/4a2f62751b9600a31a0d3c78100287f1)。Discord 公式とのトラブルがあったようです(詳しくはググってね)。後述しますが、_現在は開発が再開されたようです。_\r\n\r\nこれにより、Discord 公式の REST API の仕様変更などに対応できなくなった discord.py 製 bot は死ぬ運命となりました(結果的にそうならなかったけど)。また、discord.py の後継を名乗るプロジェクトが林立する事態となりました。\r\n\r\nPython 界隈がこの有様(だった)ので、このチュートリアルでは discord.js を使っていきます。\r\n\r\n## 2022 年 3 月 6 日\r\n\r\n……と思っていたら 3 月 6 日に discord.py の開発**再開**が[アナウンスされました](https://gist.github.com/Rapptz/c4324f17a80c94776832430007ad40e6)。 ~~何が何だか分からん~~ 再び 2 大ライブラリ時代に戻るんじゃないかなと思っています。たぶん……\r\n\r\n# 環境構築・初期設定\r\n\r\nこの章では、Discord Bot を作るための環境構築・初期設定を行います。\r\n\r\n## 用語集\r\n\r\n初めに、基本的な用語について説明しておきます。\r\n\r\n- Node.js\r\n- サーバーサイド JavaScript 環境(ブラウザではなくサーバー上で JS を動かすための環境)の一種です。Discord Bot は Node.js 上で動きます。\r\n- パッケージマネージャとして`npm`という物を使います。\r\n- 最新の discord.js(v13)を使うためには、Node v16.6.0 以降が必要です。\r\n- [公式サイト](https://nodejs.org/ja/)\r\n- TypeScript\r\n- JavaScript を静的型付けライクに拡張した言語です。静的型付け最高！\r\n- TypeScript は直接実行することができないため、基本的には`tsc`というコンパイラで JavaScript に変換してから実行します。\r\n- 文法は C や Java などに近い感じです。\r\n- [公式サイト](https://www.typescriptlang.org/)\r\n\r\n## Node.js のインストール\r\n\r\n[ダウンロードページ](https://nodejs.org/ja/download/)から、Node.js の LTS 版をダウンロード・インストールしてください。\r\n\r\nターミナルで`node --version`を実行した際、`v16.14.0`のように表示されていればインストール成功です。\r\n\r\n## プロジェクトディレクトリの作成\r\n\r\n適当な名前のディレクトリを作ってください。\r\n\r\n次に、ターミナルでディレクトリに移動し、`npm init`を実行してください。色々聞かれますが、とりあえず全て Enter を押せばいいです。\r\n\r\n`package.json`が作成されていることを確認してください。\r\n\r\n## パッケージのインストール\r\n\r\n開発に必要なパッケージをインストールします。次のコマンドを実行してください。\r\n\r\n```bash\r\nnpm install --save discord.js dotenv typescript @types/node@16 ts-node tsconfig-paths\r\n```\r\n\r\n## TypeScript の設定\r\n\r\n`npx tsc --init`を実行してください。`tsconfig.json`が生成されれば成功です。\r\n\r\n`tsconfig.json`には、TypeScript のコンパイラ(TSC)の設定情報が含まれています。\r\n\r\n`tsconfig.json`には設定項目が大量にありますが、中身については省略します。`baseUrl`の項目だけ次のように変えてください。\r\n\r\n```json\r\n{\r\n  // ...\r\n  "baseUrl": "./src"\r\n  // ...\r\n}\r\n```\r\n\r\n## スクリプトの設定\r\n\r\n`package.json`の`"scripts"`の箇所を次のように編集してください。\r\n\r\n```json\r\n{\r\n  // ...\r\n  "scripts": {\r\n    "start": "ts-node --files -r tsconfig-paths/register src/index.ts"\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\nこれにより、`npm start`で`npx ts-node --files -r tsconfig-paths/register src/index.ts`を実行できるようになりました。\r\n\r\n`ts-node`は、`.ts`ファイルを事前コンパイル無しで直接実行するためのパッケージです(正確には JIT コンパイルしているようです)。TypeScript のコードを走らせるには「tsc でコンパイル」→「Node で js を実行」 の 2 ステップを要していましたが、`ts-node`を使うことで 1 ステップに抑えることができます。\r\n\r\nいろいろ引数がついていますが、ここでは説明を省略します。気になる方は`tsconfig-paths`などで検索してください。\r\n\r\n## Hello World\r\n\r\n`src`ディレクトリを作成し、その中に`index.ts`を作成してください。\r\n\r\nそして、次のコードをコピペしてください。\r\n\r\n```typescript\r\nconsole.log("Hello World!");\r\n```\r\n\r\n最後に、プロジェクトルートに居る状態で`npm start`を実行してください。`Hello World!`と表示されれば成功です！\r\n\r\n# Bot の登録・ログイン\r\n\r\nこの章では、Discord Bot をサーバーに追加した後、Bot をサーバーにログインさせます。\r\n\r\n概ね[Discord.js Guide](https://guide.discordjs-japan.org/) v12 版に沿っていますが、現行の v13 に合わせて記述を変更している箇所もあります。\r\n\r\n## Bot をサーバーに追加する\r\n\r\nBot をサーバーに追加していきます。最初にテスト用のサーバーを立てておいてください。\r\n\r\n### Bot の登録\r\n\r\nまずは Bot を Discord に登録します。\r\n\r\n1. Discord にログインした状態で、Discord Developer Portal の[Application](https://discord.com/developers/applications/)ページに移動してください。\r\n2. 右上の`New Application`をクリックして、いい感じの名前をつけて`Create`してください。\r\n\r\n![creat app](./create-app.webp)\r\n\r\n3. 左のメニューから`Bot`をクリックして、`Add Bot -> Yes, do it!`をクリックしてください。`A wild bot has appeared!`みたいなメッセージが表示されれば OK です。\r\n\r\n![add bot](./add-bot.webp)\r\n\r\n### Bot をサーバーに招待\r\n\r\n次に、Bot をサーバーに招待します。\r\n\r\n1. 左メニューから`OAuth2 -> URL Generator`を開いてください。\r\n2. `SCOPES`の中の`bot`, `applications.commands`にチェックを入れてください。\r\n3. `BOT PERMISSIONS`の中の`Send Messages`にチェックを入れてください。これにより、Bot にメッセージ送信権限が付与されます。他の権限が必要な場合は適宜チェックを増やしてください。\r\n\r\n![permission](./permission.webp)\r\n\r\n4. 下の方にある`Generated URL`をコピーして、Web ブラウザに貼り付けてください。事前に作成したサーバーを選択して、「はい」などのボタンを押してください。\r\n5. Discord クライアント上で、サーバーに Bot が追加されたことを確認してください。\r\n\r\n## Bot をサーバーにログインさせる\r\n\r\n### 環境変数と dotenv\r\n\r\nこれから Bot をサーバーにログインさせますが、その前に環境変数について説明しておきます。\r\n\r\nBot をログインさせる際には「トークン」という値が必要になります。この値が外部に流出した場合、他の人が Bot をサーバーにログインさせて、スパムメッセージを送信するなどの悪事を働くことができてしまいます。このため、トークンはソースコードに**埋め込まずに**管理する必要があります(トークンを埋め込んだソースコードを Git に Push したら外部流出したことになります)。\r\n\r\nこのような機密情報は、実行環境の**環境変数**に設定して、ソースコードから環境変数を読み込む必要があります。しかし、環境変数を設定するのは割とだるいです。\r\n\r\nNode では、実行時に`.env`というファイルから環境変数を読み込んで設定する`dotenv`というモジュールがあります。実はこのモジュールは前章でインストールしていました。`.env`ファイルを`.gitignore`に設定することで、機密情報を安全に、便利に扱うことができます。\r\n\r\nトークンを`.env`ファイルに保存しておきましょう。`.env`をルートディレクトリに作成して、次の内容を書き込んでください。\r\n\r\n```\r\nTOKEN=<Botのトークン>\r\n```\r\n\r\n`<Botのトークン>`の箇所を実際の値で置き換えてください。Bot のトークンは次のようにして得ることができます。\r\n\r\n1. Developer Portal から前節で作成したアプリケーションを選択し、左メニューの`Bot`を選択します。\r\n2. `TOKEN`という所に`Copy`ボタンがあるのでクリックしてください。トークンがクリップボードにコピーされます。\r\n\r\n### ログイン処理の実装\r\n\r\nBot をサーバーにログインさせる処理を書いていきます。\r\n\r\n```typescript\r\n// 1: インポート\r\nimport * as dotenv from "dotenv";\r\nimport { Client, ClientOptions } from "discord.js";\r\n\r\n// 2: .envを読み込み、環境変数に登録\r\ndotenv.config();\r\n\r\n// 3: クライアントを初期化\r\nconst clientOptions: ClientOptions = {\r\n  intents: ["GUILD_MESSAGES", "GUILDS"],\r\n};\r\nconst client = new Client(clientOptions);\r\n\r\n// 4: ログイン完了時に実行するコールバック関数を登録\r\nclient.once("ready", () => {\r\n  console.log("I\'m  ready!");\r\n});\r\n\r\n// 5: ログイン\r\nclient.login(process.env.TOKEN);\r\n```\r\n\r\nコードの中身を説明していきます。\r\n\r\n#### インポート\r\n\r\n使用するクラスなどをインポートします。\r\n\r\n#### .env を読み込み、環境変数に登録\r\n\r\n`.env`を読み込んで、環境変数に登録します。環境変数へは`process.env.<変数名>`でアクセスすることができます。\r\n\r\n#### クライアントを初期化\r\n\r\n- `v12`以前と異なり、現行の`v13`では`ClientOptions`が必須になっています。\r\n- `ClientOptions`の`intents`で、どのイベントを Bot が受信するかを制御します。ここでは上記 2 つを指定しておけば良いでしょう。\r\n- 最後にクライアントのインスタンスを作成します。\r\n\r\n#### ログイン完了時に実行するコールバック関数を登録\r\n\r\n- ログイン完了時に`ready`イベントが発火されます。その時に実行する関数(コールバック関数)を登録しておきます。\r\n- `()=>{...}`という表記は、JS・TS 特有の「アロー関数」という物です。(詳しくはググってね)\r\n\r\n#### ログイン\r\n\r\n- 環境変数`TOKEN`の値を引数にしてログインします。\r\n\r\n### 実行してみる\r\n\r\nここまで書けたら実際に実行してみましょう。\r\n\r\n`npm start`を実行して数秒待ってください。次のことが確認できれば成功です！\r\n\r\n- コンソールに`I\'m ready!`と表示される。\r\n- Discord アプリ上で、登録した Bot がオンラインになっている。\r\n\r\n確認できたら、Ctrl+C などで Bot を止めておいてください。\r\n\r\n# スラッシュコマンド\r\n\r\nこの章では、スラッシュコマンドの実装を行います。\r\n\r\nこの記事を参考にしています: [discord.js でスラッシュコマンド（Slash commands）を使う - Qiita](https://qiita.com/gaato/items/55b32bc4777905ac162a)\r\n\r\n## 2 種類のスラッシュコマンド\r\n\r\nスラッシュコマンドには「ギルドコマンド」と「グローバルコマンド」の 2 種類があります。\r\n\r\n- ギルドコマンド: 特定のサーバーを指定して登録するコマンド。\r\n- グローバルコマンド: Bot が参加している全てのサーバーに登録されるコマンド。\r\n\r\nグローバルコマンドは、登録後実際に使えるようになるまで 1 時間ほどかかるようです。このため、本チュートリアルではギルドコマンドを使用します。\r\n\r\n## 環境変数の設定\r\n\r\nギルドコマンドを登録するためには、対象サーバーの ID が必要です。`.env`に保存しておきます。\r\n\r\nサーバー ID は次の方法で取得することができます。\r\n\r\n1. Discord アプリの設定画面を開き、「詳細設定」の「開発者モード」をオンにしておきます。\r\n\r\n![dev mode](./dev-mode.webp)\r\n\r\n1. サーバーアイコン上で右クリックして、「ID をコピー」を選択します。サーバー ID がクリップボードにコピーされます。\r\n\r\n![copy server id](./copy-server-id.webp)\r\n\r\n`.env`に次の項目を追記してください。`<サーバーID>`は実際の値に置き換えてください。\r\n\r\n```\r\nSERVER_ID=<サーバーID>\r\n```\r\n\r\n## シンプルなコマンド\r\n\r\nまず、`pong`というメッセージを送信するだけのシンプルなコマンド`/ping`を作成してみます。\r\n\r\n### 環境変数の型定義を記述する\r\n\r\n環境変数の型定義ファイルを作っておかないと後々面倒なので、ここで作ってしまいます。\r\n\r\n`src`に`@types`ディレクトリを作成して、中に`global.d.ts`を作り、以下の内容を入力してください。\r\n\r\n```typescript\r\ndeclare namespace NodeJS {\r\n  interface ProcessEnv {\r\n    readonly TOKEN: string;\r\n    readonly SERVER_ID: string;\r\n  }\r\n}\r\n```\r\n\r\n### コマンドを実装する\r\n\r\n実際にコマンドを作っていきます。次のコードを参考にして、`ready`イベントのコールバックを編集し、`interactionCreate`イベントのコールバックを追加してください。`async`キーワードが新しく加わっていることに注意してください。\r\n\r\n```typescript\r\nimport { ApplicationCommandData, Client, ClientOptions } from "discord.js"; // インポート部分が変わっています\r\n\r\n// ...\r\n\r\n// ログイン完了時に実行するコールバック関数を登録\r\nclient.once("ready", async () => {\r\n  const commands: ApplicationCommandData[] = [\r\n    {\r\n      name: "ping",\r\n      description: "pongと返します。",\r\n    },\r\n  ];\r\n  await client.application?.commands.set(commands, process.env.SERVER_ID);\r\n\r\n  console.log("I\'m  ready!");\r\n});\r\n\r\n// コマンド受信時のコールバック関数を登録\r\nclient.on("interactionCreate", async (interaction) => {\r\n  if (!interaction.isCommand()) {\r\n    return;\r\n  }\r\n  if (interaction.commandName === "ping") {\r\n    // pingコマンドが来たら:\r\n    await interaction.reply("pong"); // pongとreplyする\r\n  }\r\n});\r\n```\r\n\r\n書けたら`npm start`して、アプリ上でコマンドを使えるかどうか確認してみましょう。\r\n\r\n## 引数付きコマンド\r\n\r\n引数を受け取るコマンドを作っていきます。ここでは、引数をそのまま出力する`echo`コマンドを作っていきます。\r\n\r\n### コマンドの登録\r\n\r\n次のコードを参考にして、`commands`に要素を追加してください。引数は`options`プロパティで設定します。\r\n\r\n```typescript\r\nconst commands: ApplicationCommandData[] = [\r\n  {\r\n    name: "ping",\r\n    description: "pongと返します。",\r\n  },\r\n  {\r\n    name: "echo",\r\n    description: "入力された文字をそのまま返します。",\r\n    options: [\r\n      {\r\n        type: "STRING",\r\n        name: "value",\r\n        description: "文字列",\r\n        required: true,\r\n      },\r\n    ],\r\n  },\r\n];\r\n```\r\n\r\n### コマンドの中身を実装\r\n\r\n次のコードを参考にして、コマンドの中身を実装してください。引数は`interaction.options.getString()`などで受け取ることができます。\r\n\r\n```typescript\r\nif (interaction.commandName === "ping") {\r\n  await interaction.reply("pong");\r\n}\r\nif (interaction.commandName === "echo") {\r\n  const value = interaction.options.getString("value", true); // 引数valueを受け取る\r\n  await interaction.reply(value);\r\n}\r\n```\r\n\r\n書けたら`npm start`して、アプリ上でコマンドを使えるかどうか確認してみましょう。\r\n\r\n## 遅延応答\r\n\r\n「コマンドを受信したら、データベースにアクセスして処理をした後に返信したい」といったケースなど、時間のかかる処理を実装したくなることがあると思います。このような処理をそのまま書いたらどうなるでしょうか？\r\n\r\n`ping`コマンドを次のように編集してみます。ここでは 4000 ミリ秒後に"pong"と返信するコードを書いています。\r\n\r\n```typescript\r\nif (interaction.commandName === "ping") {\r\n  setTimeout(async () => {\r\n    await interaction.reply("pong");\r\n  }, 4000); // 4000ミリ秒後に"pong"と返信\r\n}\r\n```\r\n\r\n`ping`コマンドを実際に実行してみましょう。すると、`アプリケーションが応答しませんでした`などのメッセージが表示されると思います。\r\n\r\n実は、スラッシュコマンドは**3 秒以内に返信しないとエラー**になります。\r\n\r\nこれを回避するため、`deferReply()`, `followUp()`という関数を使います。\r\n\r\n```typescript\r\nif (interaction.commandName === "ping") {\r\n  await interaction.deferReply(); // 追加\r\n  setTimeout(async () => {\r\n    await interaction.followUp("pong"); // 変更\r\n  }, 4000); // 4000ミリ秒後に"pong"と返信\r\n}\r\n```\r\n\r\nこのコードにした上で`ping`コマンドを実行すると、`<bot名>が考え中…`というメッセージが表示された 4 秒後に`pong`と表示されるはずです。意図通りの挙動になりました。\r\n\r\nということで、時間のかかる処理を行う時には、返信を遅延させるために`deferReply()`や`followUp()`を使う必要があります。\r\n\r\n詳しくはこのページが参考になります: [reply と deferReply の違い - Discord.js Japan User Group](https://scrapbox.io/discordjs-japan/reply%E3%81%A8deferReply%E3%81%AE%E9%81%95%E3%81%84)\r\n\r\n# 分からないことがあったら\r\n\r\n分からないことがある時は次のサイトが頼りになります。\r\n\r\n- [Discord.js Guide](https://discordjs.guide/#before-you-begin)\r\n- [discord.js Documentation](https://discord.js.org/#/docs/discord.js/stable/general/welcome)\r\n- [Discord.js Japan User Group (Scrapbox)](https://scrapbox.io/discordjs-japan/)\r\n- 日本語 Wiki。やりたいことをここで検索すれば大体出てくる説があります。\r\n\r\n# おわり\r\n\r\nスラッシュコマンドに対応した Discord Bot を作りました。後はいろいろ工夫して頑張ってください(雑)。\r\n',
    html: '\n<h1 id="user-content-discord-bot-チュートリアル">Discord Bot チュートリアル</h1>\n<p>こんにちは。B3 の Arc です。2022 年 2 月 18 日に部内で Discord Bot の開発チュートリアルを行いました。当時の資料を元に加筆・修正を加えた物を公開してみます。</p>\n<h1 id="user-content-近頃の-discord-bot-界隈">近頃の Discord Bot 界隈</h1>\n<p>最初に、近頃の Discord Bot 開発者界隈を取り巻く状況について軽く触れておきます。</p>\n<h2 id="user-content-むかし">むかし</h2>\n<p>昔は Bot 開発用の 2 大ライブラリとして、Python 用の<a href="https://discordpy.readthedocs.io/en/latest/">discord.py</a>と Node.js 用の<a href="https://discord.js.org/">discord.js</a>がありました。</p>\n<h2 id="user-content-2021-年-8-月-28-日">2021 年 8 月 28 日</h2>\n<p>この日に discord.py の開発終了が<a href="https://gist.github.com/Rapptz/4a2f62751b9600a31a0d3c78100287f1">アナウンスされました</a>。Discord 公式とのトラブルがあったようです(詳しくはググってね)。後述しますが、<em>現在は開発が再開されたようです。</em></p>\n<p>これにより、Discord 公式の REST API の仕様変更などに対応できなくなった discord.py 製 bot は死ぬ運命となりました(結果的にそうならなかったけど)。また、discord.py の後継を名乗るプロジェクトが林立する事態となりました。</p>\n<p>Python 界隈がこの有様(だった)ので、このチュートリアルでは discord.js を使っていきます。</p>\n<h2 id="user-content-2022-年-3-月-6-日">2022 年 3 月 6 日</h2>\n<p>……と思っていたら 3 月 6 日に discord.py の開発<strong>再開</strong>が<a href="https://gist.github.com/Rapptz/c4324f17a80c94776832430007ad40e6">アナウンスされました</a>。 <del>何が何だか分からん</del> 再び 2 大ライブラリ時代に戻るんじゃないかなと思っています。たぶん……</p>\n<h1 id="user-content-環境構築初期設定">環境構築・初期設定</h1>\n<p>この章では、Discord Bot を作るための環境構築・初期設定を行います。</p>\n<h2 id="user-content-用語集">用語集</h2>\n<p>初めに、基本的な用語について説明しておきます。</p>\n<ul>\n  <li>Node.js</li>\n  <li>サーバーサイド JavaScript 環境(ブラウザではなくサーバー上で JS を動かすための環境)の一種です。Discord Bot は Node.js 上で動きます。</li>\n  <li>パッケージマネージャとして<code>npm</code>という物を使います。</li>\n  <li>最新の discord.js(v13)を使うためには、Node v16.6.0 以降が必要です。</li>\n  <li><a href="https://nodejs.org/ja/">公式サイト</a></li>\n  <li>TypeScript</li>\n  <li>JavaScript を静的型付けライクに拡張した言語です。静的型付け最高！</li>\n  <li>TypeScript は直接実行することができないため、基本的には<code>tsc</code>というコンパイラで JavaScript に変換してから実行します。</li>\n  <li>文法は C や Java などに近い感じです。</li>\n  <li><a href="https://www.typescriptlang.org/">公式サイト</a></li>\n</ul>\n<h2 id="user-content-nodejs-のインストール">Node.js のインストール</h2>\n<p><a href="https://nodejs.org/ja/download/">ダウンロードページ</a>から、Node.js の LTS 版をダウンロード・インストールしてください。</p>\n<p>ターミナルで<code>node --version</code>を実行した際、<code>v16.14.0</code>のように表示されていればインストール成功です。</p>\n<h2 id="user-content-プロジェクトディレクトリの作成">プロジェクトディレクトリの作成</h2>\n<p>適当な名前のディレクトリを作ってください。</p>\n<p>次に、ターミナルでディレクトリに移動し、<code>npm init</code>を実行してください。色々聞かれますが、とりあえず全て Enter を押せばいいです。</p>\n<p><code>package.json</code>が作成されていることを確認してください。</p>\n<h2 id="user-content-パッケージのインストール">パッケージのインストール</h2>\n<p>開発に必要なパッケージをインストールします。次のコマンドを実行してください。</p>\n<div>\n  <pre><code><span><span>npm</span><span> </span><span>install</span><span> </span><span>--save</span><span> </span><span>discord.js</span><span> </span><span>dotenv</span><span> </span><span>typescript</span><span> </span><span>@types/node@16</span><span> </span><span>ts-node</span><span> </span><span>tsconfig-paths</span></span></code></pre>\n</div>\n<h2 id="user-content-typescript-の設定">TypeScript の設定</h2>\n<p><code>npx tsc --init</code>を実行してください。<code>tsconfig.json</code>が生成されれば成功です。</p>\n<p><code>tsconfig.json</code>には、TypeScript のコンパイラ(TSC)の設定情報が含まれています。</p>\n<p><code>tsconfig.json</code>には設定項目が大量にありますが、中身については省略します。<code>baseUrl</code>の項目だけ次のように変えてください。</p>\n<div>\n  <pre><code><span><span>{</span></span>\n<span><span>  </span><span>// ...</span></span>\n<span><span>  </span><span>"baseUrl"</span><span>: </span><span>"./src"</span></span>\n<span><span>  </span><span>// ...</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<h2 id="user-content-スクリプトの設定">スクリプトの設定</h2>\n<p><code>package.json</code>の<code>"scripts"</code>の箇所を次のように編集してください。</p>\n<div>\n  <pre><code><span><span>{</span></span>\n<span><span>  </span><span>// ...</span></span>\n<span><span>  </span><span>"scripts"</span><span>: {</span></span>\n<span><span>    </span><span>"start"</span><span>: </span><span>"ts-node --files -r tsconfig-paths/register src/index.ts"</span></span>\n<span><span>  }</span></span>\n<span><span>  </span><span>// ...</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>これにより、<code>npm start</code>で<code>npx ts-node --files -r tsconfig-paths/register src/index.ts</code>を実行できるようになりました。</p>\n<p><code>ts-node</code>は、<code>.ts</code>ファイルを事前コンパイル無しで直接実行するためのパッケージです(正確には JIT コンパイルしているようです)。TypeScript のコードを走らせるには「tsc でコンパイル」→「Node で js を実行」 の 2 ステップを要していましたが、<code>ts-node</code>を使うことで 1 ステップに抑えることができます。</p>\n<p>いろいろ引数がついていますが、ここでは説明を省略します。気になる方は<code>tsconfig-paths</code>などで検索してください。</p>\n<h2 id="user-content-hello-world">Hello World</h2>\n<p><code>src</code>ディレクトリを作成し、その中に<code>index.ts</code>を作成してください。</p>\n<p>そして、次のコードをコピペしてください。</p>\n<div>\n  <pre><code><span><span>console.</span><span>log</span><span>(</span><span>"Hello World!"</span><span>);</span></span></code></pre>\n</div>\n<p>最後に、プロジェクトルートに居る状態で<code>npm start</code>を実行してください。<code>Hello World!</code>と表示されれば成功です！</p>\n<h1 id="user-content-bot-の登録ログイン">Bot の登録・ログイン</h1>\n<p>この章では、Discord Bot をサーバーに追加した後、Bot をサーバーにログインさせます。</p>\n<p>概ね<a href="https://guide.discordjs-japan.org/">Discord.js Guide</a> v12 版に沿っていますが、現行の v13 に合わせて記述を変更している箇所もあります。</p>\n<h2 id="user-content-bot-をサーバーに追加する">Bot をサーバーに追加する</h2>\n<p>Bot をサーバーに追加していきます。最初にテスト用のサーバーを立てておいてください。</p>\n<h3 id="user-content-bot-の登録">Bot の登録</h3>\n<p>まずは Bot を Discord に登録します。</p>\n<ol>\n  <li>Discord にログインした状態で、Discord Developer Portal の<a href="https://discord.com/developers/applications/">Application</a>ページに移動してください。</li>\n  <li>右上の<code>New Application</code>をクリックして、いい感じの名前をつけて<code>Create</code>してください。</li>\n</ol>\n<p>\n  <img src="./create-app.webp" alt="creat app">\n</p>\n<ol start="3">\n  <li>左のメニューから<code>Bot</code>をクリックして、<code>Add Bot -> Yes, do it!</code>をクリックしてください。<code>A wild bot has appeared!</code>みたいなメッセージが表示されれば OK です。</li>\n</ol>\n<p>\n  <img src="./add-bot.webp" alt="add bot">\n</p>\n<h3 id="user-content-bot-をサーバーに招待">Bot をサーバーに招待</h3>\n<p>次に、Bot をサーバーに招待します。</p>\n<ol>\n  <li>左メニューから<code>OAuth2 -> URL Generator</code>を開いてください。</li>\n  <li><code>SCOPES</code>の中の<code>bot</code>, <code>applications.commands</code>にチェックを入れてください。</li>\n  <li><code>BOT PERMISSIONS</code>の中の<code>Send Messages</code>にチェックを入れてください。これにより、Bot にメッセージ送信権限が付与されます。他の権限が必要な場合は適宜チェックを増やしてください。</li>\n</ol>\n<p>\n  <img src="./permission.webp" alt="permission">\n</p>\n<ol start="4">\n  <li>下の方にある<code>Generated URL</code>をコピーして、Web ブラウザに貼り付けてください。事前に作成したサーバーを選択して、「はい」などのボタンを押してください。</li>\n  <li>Discord クライアント上で、サーバーに Bot が追加されたことを確認してください。</li>\n</ol>\n<h2 id="user-content-bot-をサーバーにログインさせる">Bot をサーバーにログインさせる</h2>\n<h3 id="user-content-環境変数と-dotenv">環境変数と dotenv</h3>\n<p>これから Bot をサーバーにログインさせますが、その前に環境変数について説明しておきます。</p>\n<p>Bot をログインさせる際には「トークン」という値が必要になります。この値が外部に流出した場合、他の人が Bot をサーバーにログインさせて、スパムメッセージを送信するなどの悪事を働くことができてしまいます。このため、トークンはソースコードに<strong>埋め込まずに</strong>管理する必要があります(トークンを埋め込んだソースコードを Git に Push したら外部流出したことになります)。</p>\n<p>このような機密情報は、実行環境の<strong>環境変数</strong>に設定して、ソースコードから環境変数を読み込む必要があります。しかし、環境変数を設定するのは割とだるいです。</p>\n<p>Node では、実行時に<code>.env</code>というファイルから環境変数を読み込んで設定する<code>dotenv</code>というモジュールがあります。実はこのモジュールは前章でインストールしていました。<code>.env</code>ファイルを<code>.gitignore</code>に設定することで、機密情報を安全に、便利に扱うことができます。</p>\n<p>トークンを<code>.env</code>ファイルに保存しておきましょう。<code>.env</code>をルートディレクトリに作成して、次の内容を書き込んでください。</p>\n<pre><code>TOKEN=&#x3C;Botのトークン>\n</code></pre>\n<p><code>&#x3C;Botのトークン></code>の箇所を実際の値で置き換えてください。Bot のトークンは次のようにして得ることができます。</p>\n<ol>\n  <li>Developer Portal から前節で作成したアプリケーションを選択し、左メニューの<code>Bot</code>を選択します。</li>\n  <li><code>TOKEN</code>という所に<code>Copy</code>ボタンがあるのでクリックしてください。トークンがクリップボードにコピーされます。</li>\n</ol>\n<h3 id="user-content-ログイン処理の実装">ログイン処理の実装</h3>\n<p>Bot をサーバーにログインさせる処理を書いていきます。</p>\n<div>\n  <pre><code><span><span>// 1: インポート</span></span>\n<span><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> dotenv </span><span>from</span><span> </span><span>"dotenv"</span><span>;</span></span>\n<span><span>import</span><span> { Client, ClientOptions } </span><span>from</span><span> </span><span>"discord.js"</span><span>;</span></span>\n<span> </span>\n<span><span>// 2: .envを読み込み、環境変数に登録</span></span>\n<span><span>dotenv.</span><span>config</span><span>();</span></span>\n<span> </span>\n<span><span>// 3: クライアントを初期化</span></span>\n<span><span>const</span><span> </span><span>clientOptions</span><span>:</span><span> </span><span>ClientOptions</span><span> </span><span>=</span><span> {</span></span>\n<span><span>  intents: [</span><span>"GUILD_MESSAGES"</span><span>, </span><span>"GUILDS"</span><span>],</span></span>\n<span><span>};</span></span>\n<span><span>const</span><span> </span><span>client</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Client</span><span>(clientOptions);</span></span>\n<span> </span>\n<span><span>// 4: ログイン完了時に実行するコールバック関数を登録</span></span>\n<span><span>client.</span><span>once</span><span>(</span><span>"ready"</span><span>, () </span><span>=></span><span> {</span></span>\n<span><span>  console.</span><span>log</span><span>(</span><span>"I\'m  ready!"</span><span>);</span></span>\n<span><span>});</span></span>\n<span> </span>\n<span><span>// 5: ログイン</span></span>\n<span><span>client.</span><span>login</span><span>(process.env.</span><span>TOKEN</span><span>);</span></span></code></pre>\n</div>\n<p>コードの中身を説明していきます。</p>\n<h4 id="user-content-インポート">インポート</h4>\n<p>使用するクラスなどをインポートします。</p>\n<h4 id="user-content-env-を読み込み環境変数に登録">.env を読み込み、環境変数に登録</h4>\n<p><code>.env</code>を読み込んで、環境変数に登録します。環境変数へは<code>process.env.&#x3C;変数名></code>でアクセスすることができます。</p>\n<h4 id="user-content-クライアントを初期化">クライアントを初期化</h4>\n<ul>\n  <li><code>v12</code>以前と異なり、現行の<code>v13</code>では<code>ClientOptions</code>が必須になっています。</li>\n  <li><code>ClientOptions</code>の<code>intents</code>で、どのイベントを Bot が受信するかを制御します。ここでは上記 2 つを指定しておけば良いでしょう。</li>\n  <li>最後にクライアントのインスタンスを作成します。</li>\n</ul>\n<h4 id="user-content-ログイン完了時に実行するコールバック関数を登録">ログイン完了時に実行するコールバック関数を登録</h4>\n<ul>\n  <li>ログイン完了時に<code>ready</code>イベントが発火されます。その時に実行する関数(コールバック関数)を登録しておきます。</li>\n  <li><code>()=>{...}</code>という表記は、JS・TS 特有の「アロー関数」という物です。(詳しくはググってね)</li>\n</ul>\n<h4 id="user-content-ログイン">ログイン</h4>\n<ul>\n  <li>環境変数<code>TOKEN</code>の値を引数にしてログインします。</li>\n</ul>\n<h3 id="user-content-実行してみる">実行してみる</h3>\n<p>ここまで書けたら実際に実行してみましょう。</p>\n<p><code>npm start</code>を実行して数秒待ってください。次のことが確認できれば成功です！</p>\n<ul>\n  <li>コンソールに<code>I\'m ready!</code>と表示される。</li>\n  <li>Discord アプリ上で、登録した Bot がオンラインになっている。</li>\n</ul>\n<p>確認できたら、Ctrl+C などで Bot を止めておいてください。</p>\n<h1 id="user-content-スラッシュコマンド">スラッシュコマンド</h1>\n<p>この章では、スラッシュコマンドの実装を行います。</p>\n<p>この記事を参考にしています: <a href="https://qiita.com/gaato/items/55b32bc4777905ac162a">discord.js でスラッシュコマンド（Slash commands）を使う - Qiita</a></p>\n<h2 id="user-content-2-種類のスラッシュコマンド">2 種類のスラッシュコマンド</h2>\n<p>スラッシュコマンドには「ギルドコマンド」と「グローバルコマンド」の 2 種類があります。</p>\n<ul>\n  <li>ギルドコマンド: 特定のサーバーを指定して登録するコマンド。</li>\n  <li>グローバルコマンド: Bot が参加している全てのサーバーに登録されるコマンド。</li>\n</ul>\n<p>グローバルコマンドは、登録後実際に使えるようになるまで 1 時間ほどかかるようです。このため、本チュートリアルではギルドコマンドを使用します。</p>\n<h2 id="user-content-環境変数の設定">環境変数の設定</h2>\n<p>ギルドコマンドを登録するためには、対象サーバーの ID が必要です。<code>.env</code>に保存しておきます。</p>\n<p>サーバー ID は次の方法で取得することができます。</p>\n<ol>\n  <li>Discord アプリの設定画面を開き、「詳細設定」の「開発者モード」をオンにしておきます。</li>\n</ol>\n<p>\n  <img src="./dev-mode.webp" alt="dev mode">\n</p>\n<ol>\n  <li>サーバーアイコン上で右クリックして、「ID をコピー」を選択します。サーバー ID がクリップボードにコピーされます。</li>\n</ol>\n<p>\n  <img src="./copy-server-id.webp" alt="copy server id">\n</p>\n<p><code>.env</code>に次の項目を追記してください。<code>&#x3C;サーバーID></code>は実際の値に置き換えてください。</p>\n<pre><code>SERVER_ID=&#x3C;サーバーID>\n</code></pre>\n<h2 id="user-content-シンプルなコマンド">シンプルなコマンド</h2>\n<p>まず、<code>pong</code>というメッセージを送信するだけのシンプルなコマンド<code>/ping</code>を作成してみます。</p>\n<h3 id="user-content-環境変数の型定義を記述する">環境変数の型定義を記述する</h3>\n<p>環境変数の型定義ファイルを作っておかないと後々面倒なので、ここで作ってしまいます。</p>\n<p><code>src</code>に<code>@types</code>ディレクトリを作成して、中に<code>global.d.ts</code>を作り、以下の内容を入力してください。</p>\n<div>\n  <pre><code><span><span>declare</span><span> </span><span>namespace</span><span> </span><span>NodeJS</span><span> {</span></span>\n<span><span>  </span><span>interface</span><span> </span><span>ProcessEnv</span><span> {</span></span>\n<span><span>    </span><span>readonly</span><span> </span><span>TOKEN</span><span>:</span><span> </span><span>string</span><span>;</span></span>\n<span><span>    </span><span>readonly</span><span> </span><span>SERVER_ID</span><span>:</span><span> </span><span>string</span><span>;</span></span>\n<span><span>  }</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<h3 id="user-content-コマンドを実装する">コマンドを実装する</h3>\n<p>実際にコマンドを作っていきます。次のコードを参考にして、<code>ready</code>イベントのコールバックを編集し、<code>interactionCreate</code>イベントのコールバックを追加してください。<code>async</code>キーワードが新しく加わっていることに注意してください。</p>\n<div>\n  <pre><code><span><span>import</span><span> { ApplicationCommandData, Client, ClientOptions } </span><span>from</span><span> </span><span>"discord.js"</span><span>; </span><span>// インポート部分が変わっています</span></span>\n<span> </span>\n<span><span>// ...</span></span>\n<span> </span>\n<span><span>// ログイン完了時に実行するコールバック関数を登録</span></span>\n<span><span>client.</span><span>once</span><span>(</span><span>"ready"</span><span>, </span><span>async</span><span> () </span><span>=></span><span> {</span></span>\n<span><span>  </span><span>const</span><span> </span><span>commands</span><span>:</span><span> </span><span>ApplicationCommandData</span><span>[] </span><span>=</span><span> [</span></span>\n<span><span>    {</span></span>\n<span><span>      name: </span><span>"ping"</span><span>,</span></span>\n<span><span>      description: </span><span>"pongと返します。"</span><span>,</span></span>\n<span><span>    },</span></span>\n<span><span>  ];</span></span>\n<span><span>  </span><span>await</span><span> client.application?.commands.</span><span>set</span><span>(commands, process.env.</span><span>SERVER_ID</span><span>);</span></span>\n<span> </span>\n<span><span>  console.</span><span>log</span><span>(</span><span>"I\'m  ready!"</span><span>);</span></span>\n<span><span>});</span></span>\n<span> </span>\n<span><span>// コマンド受信時のコールバック関数を登録</span></span>\n<span><span>client.</span><span>on</span><span>(</span><span>"interactionCreate"</span><span>, </span><span>async</span><span> (</span><span>interaction</span><span>) </span><span>=></span><span> {</span></span>\n<span><span>  </span><span>if</span><span> (</span><span>!</span><span>interaction.</span><span>isCommand</span><span>()) {</span></span>\n<span><span>    </span><span>return</span><span>;</span></span>\n<span><span>  }</span></span>\n<span><span>  </span><span>if</span><span> (interaction.commandName </span><span>===</span><span> </span><span>"ping"</span><span>) {</span></span>\n<span><span>    </span><span>// pingコマンドが来たら:</span></span>\n<span><span>    </span><span>await</span><span> interaction.</span><span>reply</span><span>(</span><span>"pong"</span><span>); </span><span>// pongとreplyする</span></span>\n<span><span>  }</span></span>\n<span><span>});</span></span></code></pre>\n</div>\n<p>書けたら<code>npm start</code>して、アプリ上でコマンドを使えるかどうか確認してみましょう。</p>\n<h2 id="user-content-引数付きコマンド">引数付きコマンド</h2>\n<p>引数を受け取るコマンドを作っていきます。ここでは、引数をそのまま出力する<code>echo</code>コマンドを作っていきます。</p>\n<h3 id="user-content-コマンドの登録">コマンドの登録</h3>\n<p>次のコードを参考にして、<code>commands</code>に要素を追加してください。引数は<code>options</code>プロパティで設定します。</p>\n<div>\n  <pre><code><span><span>const</span><span> </span><span>commands</span><span>:</span><span> </span><span>ApplicationCommandData</span><span>[] </span><span>=</span><span> [</span></span>\n<span><span>  {</span></span>\n<span><span>    name: </span><span>"ping"</span><span>,</span></span>\n<span><span>    description: </span><span>"pongと返します。"</span><span>,</span></span>\n<span><span>  },</span></span>\n<span><span>  {</span></span>\n<span><span>    name: </span><span>"echo"</span><span>,</span></span>\n<span><span>    description: </span><span>"入力された文字をそのまま返します。"</span><span>,</span></span>\n<span><span>    options: [</span></span>\n<span><span>      {</span></span>\n<span><span>        type: </span><span>"STRING"</span><span>,</span></span>\n<span><span>        name: </span><span>"value"</span><span>,</span></span>\n<span><span>        description: </span><span>"文字列"</span><span>,</span></span>\n<span><span>        required: </span><span>true</span><span>,</span></span>\n<span><span>      },</span></span>\n<span><span>    ],</span></span>\n<span><span>  },</span></span>\n<span><span>];</span></span></code></pre>\n</div>\n<h3 id="user-content-コマンドの中身を実装">コマンドの中身を実装</h3>\n<p>次のコードを参考にして、コマンドの中身を実装してください。引数は<code>interaction.options.getString()</code>などで受け取ることができます。</p>\n<div>\n  <pre><code><span><span>if</span><span> (interaction.commandName </span><span>===</span><span> </span><span>"ping"</span><span>) {</span></span>\n<span><span>  </span><span>await</span><span> interaction.</span><span>reply</span><span>(</span><span>"pong"</span><span>);</span></span>\n<span><span>}</span></span>\n<span><span>if</span><span> (interaction.commandName </span><span>===</span><span> </span><span>"echo"</span><span>) {</span></span>\n<span><span>  </span><span>const</span><span> </span><span>value</span><span> </span><span>=</span><span> interaction.options.</span><span>getString</span><span>(</span><span>"value"</span><span>, </span><span>true</span><span>); </span><span>// 引数valueを受け取る</span></span>\n<span><span>  </span><span>await</span><span> interaction.</span><span>reply</span><span>(value);</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>書けたら<code>npm start</code>して、アプリ上でコマンドを使えるかどうか確認してみましょう。</p>\n<h2 id="user-content-遅延応答">遅延応答</h2>\n<p>「コマンドを受信したら、データベースにアクセスして処理をした後に返信したい」といったケースなど、時間のかかる処理を実装したくなることがあると思います。このような処理をそのまま書いたらどうなるでしょうか？</p>\n<p><code>ping</code>コマンドを次のように編集してみます。ここでは 4000 ミリ秒後に"pong"と返信するコードを書いています。</p>\n<div>\n  <pre><code><span><span>if</span><span> (interaction.commandName </span><span>===</span><span> </span><span>"ping"</span><span>) {</span></span>\n<span><span>  </span><span>setTimeout</span><span>(</span><span>async</span><span> () </span><span>=></span><span> {</span></span>\n<span><span>    </span><span>await</span><span> interaction.</span><span>reply</span><span>(</span><span>"pong"</span><span>);</span></span>\n<span><span>  }, </span><span>4000</span><span>); </span><span>// 4000ミリ秒後に"pong"と返信</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p><code>ping</code>コマンドを実際に実行してみましょう。すると、<code>アプリケーションが応答しませんでした</code>などのメッセージが表示されると思います。</p>\n<p>実は、スラッシュコマンドは<strong>3 秒以内に返信しないとエラー</strong>になります。</p>\n<p>これを回避するため、<code>deferReply()</code>, <code>followUp()</code>という関数を使います。</p>\n<div>\n  <pre><code><span><span>if</span><span> (interaction.commandName </span><span>===</span><span> </span><span>"ping"</span><span>) {</span></span>\n<span><span>  </span><span>await</span><span> interaction.</span><span>deferReply</span><span>(); </span><span>// 追加</span></span>\n<span><span>  </span><span>setTimeout</span><span>(</span><span>async</span><span> () </span><span>=></span><span> {</span></span>\n<span><span>    </span><span>await</span><span> interaction.</span><span>followUp</span><span>(</span><span>"pong"</span><span>); </span><span>// 変更</span></span>\n<span><span>  }, </span><span>4000</span><span>); </span><span>// 4000ミリ秒後に"pong"と返信</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<p>このコードにした上で<code>ping</code>コマンドを実行すると、<code>&#x3C;bot名>が考え中…</code>というメッセージが表示された 4 秒後に<code>pong</code>と表示されるはずです。意図通りの挙動になりました。</p>\n<p>ということで、時間のかかる処理を行う時には、返信を遅延させるために<code>deferReply()</code>や<code>followUp()</code>を使う必要があります。</p>\n<p>詳しくはこのページが参考になります: <a href="https://scrapbox.io/discordjs-japan/reply%E3%81%A8deferReply%E3%81%AE%E9%81%95%E3%81%84">reply と deferReply の違い - Discord.js Japan User Group</a></p>\n<h1 id="user-content-分からないことがあったら">分からないことがあったら</h1>\n<p>分からないことがある時は次のサイトが頼りになります。</p>\n<ul>\n  <li><a href="https://discordjs.guide/#before-you-begin">Discord.js Guide</a></li>\n  <li><a href="https://discord.js.org/#/docs/discord.js/stable/general/welcome">discord.js Documentation</a></li>\n  <li><a href="https://scrapbox.io/discordjs-japan/">Discord.js Japan User Group (Scrapbox)</a></li>\n  <li>日本語 Wiki。やりたいことをここで検索すれば大体出てくる説があります。</li>\n</ul>\n<h1 id="user-content-おわり">おわり</h1>\n<p>スラッシュコマンドに対応した Discord Bot を作りました。後はいろいろ工夫して頑張ってください(雑)。</p>\n',
  },
  {
    title: 'Git・GitHub講習',
    date: '2023-05-01T00:00:00.000Z',
    author: 'ojii3',
    tags: ['git', 'github'],
    rootPath: 'content/blog/2023-04-newbie-training/git/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown:
      '\n# 目次\n\n- Git/GitHub とは\n- Git\n  - Git のインストール\n  - Git クライアント(GUI)\n  - ローカルリポジトリの操作\n    - 初期化(`init`)\n    - ステージング\n    - コミット(`commit`)\n- GitHub\n  - GitHub アカウントの作成\n  - ssh キーの作成と登録\n  - リモートリポジトリの操作(1)\n    - 作成\n    - クローン(`clone`)\n    - プッシュ(`push`)\n    - プル(`pull`)\n- チーム開発\n  - Organization への参加\n  - リモートリポジトリの操作(2)\n    - ブランチの作成\n    - ブランチのマージ\n    - プルリクエスト\n    - プルリクエストのマージ\n    - プルリクエストの承認\n\n# 準備編\n\nWSL 環境を前提とします。\n\n## Git のインストール\n\nGit を使うには、まず Git をインストールする必要があります。以下の手順でインストールしましょう。\n\n1. Git の公式ダウンロードサイト（https://git-scm.com/downloads）にアクセスします。\n2. 今回は WSL にインストールするので、Linux/Unix → Ubuntu のインストール方法を確認します。\n3. WSL を開き、指示にしたがってコマンドを実行します。コマンドの先頭に`sudo`権限を付与しましょう。以下のようなコマンドを実行することになるはずです。\n\n```shell: bash\nsudo  add-apt-repository ppa:git-core/ppa\n```\n\n```shell: bash\nsudo update\n```\n\n```shell: bash\nsudo  apt install git\n```\n\n(ひょっとして Windows 側に入れたほうが良かったりするかな...?)\n\n(必要になったら自分で入れてください。ただし、改行コードのデフォルト設定には注意です。)\n\n## Git クライアント(GUI)のインストール\n\nコマンドを覚えるのは大変なので、とりあえず GUI で Git を使えるようになりましょう。\n\n1. 様々なツールがあります。公式がまとめているサイト(https://git-scm.com/download/gui/windows)を見てみましょう。\n2. 今回は Source Tree をインストールします。Windows 側にインストールし、Windows 側から WSL のディレクトリにアクセスして使います。(Linux で動かないソフトも使えるのが wsl のメリットではありますね...)\n3. 使い方がうろ覚えなので、部室 PC でみんなといっしょに操作しようと思います...\n\n(VSCode にビルトインで GUI クライアントがくっついていたりします。IDE には普通にくっついています。)\n\n(VSCode で教えちゃおうかな...)\n\n## GitHub アカウントの作成\n\n次に、GitHub のアカウントを作成しましょう。\n\n1. GitHub の公式サイト（https://github.com/）にアクセスします。\n2. "Sign up"をクリックし、必要事項を入力します。\n3. "Create account"をクリックして、アカウントを作成します。\n\n(モバイルアプリ入れておくと通学中とか GitHub サーフィンできるよ。あとモバイル認証用。)\n\n## ssh キーの作成と登録\n\nGitHub では、SSH という通信を使って Git と通信します。SSH キーを作成し、GitHub に登録しましょう。\n\n1. Git Bash を起動します。\n2. ssh-keygen コマンドを実行します。すると、秘密鍵と公開鍵が生成されます。\n3. 公開鍵を GitHub に登録します。GitHub の"Settings"→"SSH and GPG keys"から"New SSH key"をクリックし、公開鍵を入力して登録します。タイトルは PC の機種名と OS 名あたりでいいんじゃないでしょうか\n\n# 実践編 壱\n\nさて、準備はコレで完了しました。\n\n使い方について学んでいきましょう。\n\n## リポジトリの作成\n\nGitHub にログインし、`New`ボタンをクリックして、リポジトリを作成します。名前は適当に`clang-reversi`とでもしておきましょう。\n\n## リポジトリのクローン(clone)\n\nクローンとは、GitHub 上のリポジトリを自分の PC にコピーすることです。\n\n今回は、自分でリポジトリを作成するので、クローンはしません。\n\n# 実践編 弐\n\n自分の PC 上の操作か、オンライン上での操作かを意識できるようになると良いです。\n\n## Organization への参加\n\nこれは我々がやることです。Organization のリポジトリ(`tuatmcc/○○`)を作ったり、開発に参加することができるようになります。\n\n## チーム開発の仕方\n\n今すぐチーム開発をするわけではないので(してもいいけど)、今完璧に覚える必要はありません。\n\n1. GitHub の `New` ボタンから、`GitLecture2023`と言う名前でリポジトリを作成してみましょう。visiblity は public で結構です\n2. GitHub の `Clone` ボタンから、SSH の URL をコピーしましょう。\n3. Git クライアントから、URL に先ほどコピーしたものを指定し、クローンします。\n4. 出来上がったディレクトリ(フォルダー)の中に、`hello.c`というプログラムを作成してください。\n\n使用するプログラムの例\n\n```c :hello.c\n#include <stdio.h>\n\nint main() {\n    printf("Hello, World!");\n    return 0;\n}\n```\n\n5. 保存したらステージングし、プッシュします。\n6. 最初の一人目のプッシュが成功し、リモート(GitHub)が更新されます。(それ以外の人たちのプッシュはちゃんと失敗するはずです)\n7. プッシュが通った最初の一人目以外は、一旦書いたプログラムを消してから、プルします。(リモートのコードが反映されるはずです)\n8. 出力内容を適当に変更し、同じことをしてみましょう。\n9. ここで、グラフ(ツリー)を見ると、誰がいつコミットしたかがわかります。試しに、一回目のコミットをダブルクリックしてみましょう。(コードが一回目のコミットの状態に戻るはずです)\n\nさて、バージョン管理ができるというのがぼんやりとわかったかと思いますが(わかってほしい)、このままではまともに複数人で開発できません。\n\nまず、タスクを分ける必要があります。普通、複数人で同時に同じファイルを編集することはありません。それぞれが独立した機能を開発する必要があります。\n\nまた、先程の様に`main`ブランチに直接コミットするのはやめましょう。`main`ブランチは、普通、リリース用のブランチとして使いますので、開発途中のコードやコミットが混ざるのは良くないです。\n\nそこで、新たにブランチを作成し、そこで開発を行います。開発が完了したら、`main`ブランチにマージします。\n\n1. ブランチを作成します。ブランチは、コミットの履歴を分岐させるものです。ブランチを作成すると、そのブランチのコミットは、元のブランチのコミットとは別のものになります。\n2. 今回は、`main`ブランチから`feature/個人名`ブランチを作成します。個別の機能を開発するブランチは、`feature/`という名前にするのが一般的です。\n3. 新しいブランチで\n',
    html: '\n<h1 id="user-content-目次">目次</h1>\n<ul>\n  <li>Git/GitHub とは</li>\n  <li>Git\n    <ul>\n      <li>Git のインストール</li>\n      <li>Git クライアント(GUI)</li>\n      <li>ローカルリポジトリの操作\n        <ul>\n          <li>初期化(<code>init</code>)</li>\n          <li>ステージング</li>\n          <li>コミット(<code>commit</code>)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>GitHub\n    <ul>\n      <li>GitHub アカウントの作成</li>\n      <li>ssh キーの作成と登録</li>\n      <li>リモートリポジトリの操作(1)\n        <ul>\n          <li>作成</li>\n          <li>クローン(<code>clone</code>)</li>\n          <li>プッシュ(<code>push</code>)</li>\n          <li>プル(<code>pull</code>)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>チーム開発\n    <ul>\n      <li>Organization への参加</li>\n      <li>リモートリポジトリの操作(2)\n        <ul>\n          <li>ブランチの作成</li>\n          <li>ブランチのマージ</li>\n          <li>プルリクエスト</li>\n          <li>プルリクエストのマージ</li>\n          <li>プルリクエストの承認</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<h1 id="user-content-準備編">準備編</h1>\n<p>WSL 環境を前提とします。</p>\n<h2 id="user-content-git-のインストール">Git のインストール</h2>\n<p>Git を使うには、まず Git をインストールする必要があります。以下の手順でインストールしましょう。</p>\n<ol>\n  <li>Git の公式ダウンロードサイト（<a href="https://git-scm.com/downloads%EF%BC%89%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82">https://git-scm.com/downloads）にアクセスします。</a></li>\n  <li>今回は WSL にインストールするので、Linux/Unix → Ubuntu のインストール方法を確認します。</li>\n  <li>WSL を開き、指示にしたがってコマンドを実行します。コマンドの先頭に<code>sudo</code>権限を付与しましょう。以下のようなコマンドを実行することになるはずです。</li>\n</ol>\n<div>\n  <pre><code><span><span>sudo  add-apt-repository ppa:git-core/ppa</span></span></code></pre>\n</div>\n<div>\n  <pre><code><span><span>sudo update</span></span></code></pre>\n</div>\n<div>\n  <pre><code><span><span>sudo  apt install git</span></span></code></pre>\n</div>\n<p>(ひょっとして Windows 側に入れたほうが良かったりするかな...?)</p>\n<p>(必要になったら自分で入れてください。ただし、改行コードのデフォルト設定には注意です。)</p>\n<h2 id="user-content-git-クライアントguiのインストール">Git クライアント(GUI)のインストール</h2>\n<p>コマンドを覚えるのは大変なので、とりあえず GUI で Git を使えるようになりましょう。</p>\n<ol>\n  <li>様々なツールがあります。公式がまとめているサイト(<a href="https://git-scm.com/download/gui/windows)%E3%82%92%E8%A6%8B%E3%81%A6%E3%81%BF%E3%81%BE%E3%81%97%E3%82%87%E3%81%86%E3%80%82">https://git-scm.com/download/gui/windows)を見てみましょう。</a></li>\n  <li>今回は Source Tree をインストールします。Windows 側にインストールし、Windows 側から WSL のディレクトリにアクセスして使います。(Linux で動かないソフトも使えるのが wsl のメリットではありますね...)</li>\n  <li>使い方がうろ覚えなので、部室 PC でみんなといっしょに操作しようと思います...</li>\n</ol>\n<p>(VSCode にビルトインで GUI クライアントがくっついていたりします。IDE には普通にくっついています。)</p>\n<p>(VSCode で教えちゃおうかな...)</p>\n<h2 id="user-content-github-アカウントの作成">GitHub アカウントの作成</h2>\n<p>次に、GitHub のアカウントを作成しましょう。</p>\n<ol>\n  <li>GitHub の公式サイト（<a href="https://github.com/%EF%BC%89%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82">https://github.com/）にアクセスします。</a></li>\n  <li>"Sign up"をクリックし、必要事項を入力します。</li>\n  <li>"Create account"をクリックして、アカウントを作成します。</li>\n</ol>\n<p>(モバイルアプリ入れておくと通学中とか GitHub サーフィンできるよ。あとモバイル認証用。)</p>\n<h2 id="user-content-ssh-キーの作成と登録">ssh キーの作成と登録</h2>\n<p>GitHub では、SSH という通信を使って Git と通信します。SSH キーを作成し、GitHub に登録しましょう。</p>\n<ol>\n  <li>Git Bash を起動します。</li>\n  <li>ssh-keygen コマンドを実行します。すると、秘密鍵と公開鍵が生成されます。</li>\n  <li>公開鍵を GitHub に登録します。GitHub の"Settings"→"SSH and GPG keys"から"New SSH key"をクリックし、公開鍵を入力して登録します。タイトルは PC の機種名と OS 名あたりでいいんじゃないでしょうか</li>\n</ol>\n<h1 id="user-content-実践編-壱">実践編 壱</h1>\n<p>さて、準備はコレで完了しました。</p>\n<p>使い方について学んでいきましょう。</p>\n<h2 id="user-content-リポジトリの作成">リポジトリの作成</h2>\n<p>GitHub にログインし、<code>New</code>ボタンをクリックして、リポジトリを作成します。名前は適当に<code>clang-reversi</code>とでもしておきましょう。</p>\n<h2 id="user-content-リポジトリのクローンclone">リポジトリのクローン(clone)</h2>\n<p>クローンとは、GitHub 上のリポジトリを自分の PC にコピーすることです。</p>\n<p>今回は、自分でリポジトリを作成するので、クローンはしません。</p>\n<h1 id="user-content-実践編-弐">実践編 弐</h1>\n<p>自分の PC 上の操作か、オンライン上での操作かを意識できるようになると良いです。</p>\n<h2 id="user-content-organization-への参加">Organization への参加</h2>\n<p>これは我々がやることです。Organization のリポジトリ(<code>tuatmcc/○○</code>)を作ったり、開発に参加することができるようになります。</p>\n<h2 id="user-content-チーム開発の仕方">チーム開発の仕方</h2>\n<p>今すぐチーム開発をするわけではないので(してもいいけど)、今完璧に覚える必要はありません。</p>\n<ol>\n  <li>GitHub の <code>New</code> ボタンから、<code>GitLecture2023</code>と言う名前でリポジトリを作成してみましょう。visiblity は public で結構です</li>\n  <li>GitHub の <code>Clone</code> ボタンから、SSH の URL をコピーしましょう。</li>\n  <li>Git クライアントから、URL に先ほどコピーしたものを指定し、クローンします。</li>\n  <li>出来上がったディレクトリ(フォルダー)の中に、<code>hello.c</code>というプログラムを作成してください。</li>\n</ol>\n<p>使用するプログラムの例</p>\n<div>\n  <pre><code><span><span>#include</span><span> </span><span>&#x3C;stdio.h></span></span>\n<span> </span>\n<span><span>int</span><span> </span><span>main</span><span>() {</span></span>\n<span><span>    </span><span>printf</span><span>(</span><span>"Hello, World!"</span><span>);</span></span>\n<span><span>    </span><span>return</span><span> </span><span>0</span><span>;</span></span>\n<span><span>}</span></span></code></pre>\n</div>\n<ol start="5">\n  <li>保存したらステージングし、プッシュします。</li>\n  <li>最初の一人目のプッシュが成功し、リモート(GitHub)が更新されます。(それ以外の人たちのプッシュはちゃんと失敗するはずです)</li>\n  <li>プッシュが通った最初の一人目以外は、一旦書いたプログラムを消してから、プルします。(リモートのコードが反映されるはずです)</li>\n  <li>出力内容を適当に変更し、同じことをしてみましょう。</li>\n  <li>ここで、グラフ(ツリー)を見ると、誰がいつコミットしたかがわかります。試しに、一回目のコミットをダブルクリックしてみましょう。(コードが一回目のコミットの状態に戻るはずです)</li>\n</ol>\n<p>さて、バージョン管理ができるというのがぼんやりとわかったかと思いますが(わかってほしい)、このままではまともに複数人で開発できません。</p>\n<p>まず、タスクを分ける必要があります。普通、複数人で同時に同じファイルを編集することはありません。それぞれが独立した機能を開発する必要があります。</p>\n<p>また、先程の様に<code>main</code>ブランチに直接コミットするのはやめましょう。<code>main</code>ブランチは、普通、リリース用のブランチとして使いますので、開発途中のコードやコミットが混ざるのは良くないです。</p>\n<p>そこで、新たにブランチを作成し、そこで開発を行います。開発が完了したら、<code>main</code>ブランチにマージします。</p>\n<ol>\n  <li>ブランチを作成します。ブランチは、コミットの履歴を分岐させるものです。ブランチを作成すると、そのブランチのコミットは、元のブランチのコミットとは別のものになります。</li>\n  <li>今回は、<code>main</code>ブランチから<code>feature/個人名</code>ブランチを作成します。個別の機能を開発するブランチは、<code>feature/</code>という名前にするのが一般的です。</li>\n  <li>新しいブランチで</li>\n</ol>\n',
  },
  {
    title: '2023年度新入生向けC言語講習',
    date: '2023-04-15T00:00:00.000Z',
    rootPath: 'content/blog/2023-04-newbie-training/clang/index.md',
    postType: 'Blog',
    globPattern: 'content/blog/**/index.md',
    markdown: '\n# nesting1\n\n',
    html: '\n<h1 id="user-content-nesting1">nesting1</h1>\n',
  },
];

export const allNews: PostTypeNews[] = [
  {
    title: '2022年度春合宿を行いました',
    description: '2022年度春合宿を行い、2泊3日でハッカソンや観光をしました',
    date: '2023-03-18',
    img: './camp-2.jpeg',
    rootPath: 'content/news/2023-03-spring-camp/index.md',
    postType: 'News',
    globPattern: 'content/news/**/index.md',
    markdown:
      '\n# 概要\n\n上郷・森の家にて2泊3日の合宿を行いました！\n9人が参加し、観光🛥️・バーベキュー🍖・ハッカソン💻などをしました。\n\n![image](./camp-1.jpeg)\n![image](./camp-2.jpeg)\n![image](./camp-3.jpeg)\n\n# ハッカソン\n\nハッカソンでは参加者が3人ずつの3人チームに分かれ、\nそれぞれのテーマに沿って開発を行いました。各チームが制作したものを紹介します。\n\n## Aチーム: Brainf**k CPU\n\nBrainf**k のコードをそのまま実行できる CPU\n\n\n16bit の PC とポインタを備えています。\n\nChisel 製で、FPGAやシミュレータを用いて動かすことができます。\n\n![image](./a-team-1.webp)\n![image](./a-team-2.webp)\n![image](./a-team-3.webp)\n\n## Bチーム\n\n制作物: オセロクイズゲーム\n\nオセロを進めてゆくと自分のところにクイズの問題文が現れていくゲームです。\n\nターンが進んでいくごとにクイズに正解した際の得点の比重が下がるので、\nオセロの実力とクイズの実力どちらも必要になっています！\n\n![image](./b-team-1.webp)\n\n## Cチーム\n\n制作物: ぼくたちのかんがえたさいきょうのろぼっと\n\n現実のタイヤやセンサーの動きを再現したロボット\n\nUnity上の仮想的な距離センサなどの情報をもとに、障害物を避けながら目的地(赤い球)まで移動します。\n\nAzure Kinect を利用し、リアルタイムで現実の地形を仮想空間に取り込むこともできます。\n\n![image](./c-team-1.webp)\n![image](./c-team-2.webp)\n\n\n',
    html: '\n<h1 id="user-content-概要">概要</h1>\n<p>\n  上郷・森の家にて2泊3日の合宿を行いました！\n  9人が参加し、観光🛥️・バーベキュー🍖・ハッカソン💻などをしました。\n</p>\n<p>\n  <img src="./camp-1.jpeg" alt="image">\n  <img src="./camp-2.jpeg" alt="image">\n  <img src="./camp-3.jpeg" alt="image">\n</p>\n<h1 id="user-content-ハッカソン">ハッカソン</h1>\n<p>\n  ハッカソンでは参加者が3人ずつの3人チームに分かれ、\n  それぞれのテーマに沿って開発を行いました。各チームが制作したものを紹介します。\n</p>\n<h2 id="user-content-aチーム-brainfk-cpu">Aチーム: Brainf**k CPU</h2>\n<p>Brainf**k のコードをそのまま実行できる CPU</p>\n<p>16bit の PC とポインタを備えています。</p>\n<p>Chisel 製で、FPGAやシミュレータを用いて動かすことができます。</p>\n<p>\n  <img src="./a-team-1.webp" alt="image">\n  <img src="./a-team-2.webp" alt="image">\n  <img src="./a-team-3.webp" alt="image">\n</p>\n<h2 id="user-content-bチーム">Bチーム</h2>\n<p>制作物: オセロクイズゲーム</p>\n<p>オセロを進めてゆくと自分のところにクイズの問題文が現れていくゲームです。</p>\n<p>\n  ターンが進んでいくごとにクイズに正解した際の得点の比重が下がるので、\n  オセロの実力とクイズの実力どちらも必要になっています！\n</p>\n<p>\n  <img src="./b-team-1.webp" alt="image">\n</p>\n<h2 id="user-content-cチーム">Cチーム</h2>\n<p>制作物: ぼくたちのかんがえたさいきょうのろぼっと</p>\n<p>現実のタイヤやセンサーの動きを再現したロボット</p>\n<p>Unity上の仮想的な距離センサなどの情報をもとに、障害物を避けながら目的地(赤い球)まで移動します。</p>\n<p>Azure Kinect を利用し、リアルタイムで現実の地形を仮想空間に取り込むこともできます。</p>\n<p>\n  <img src="./c-team-1.webp" alt="image">\n  <img src="./c-team-2.webp" alt="image">\n</p>\n',
  },
  {
    title: 'ホームページをリニューアルしました',
    description: 'MCCのホームページをシステム部分から丸ごと新しくしました。',
    img: './new-website-screenshot.webp',
    date: '2023-01-13',
    tags: ['dev', 'web', 'nextjs'],
    author: 'ojii3',
    rootPath: 'content/news/2023-01-website-renewal/index.md',
    postType: 'News',
    globPattern: 'content/news/**/index.md',
    markdown:
      '\r\nMCC のホームページをリニューアルしたのでご報告\r\n\r\n## 旧ホームページの状況\r\n\r\n![old website](./old-website-screenshot.webp)\r\n\r\n> 古典的な WEB サイトを、現代のフロントエンド・フレームワークを駆使して書き直すコンセプトです。 古臭そうな見た目をしてる割に、がっつりレスポンシブ・SPA で動きます。\r\n\r\nとのこと。(中身は Nuxt2 でした)\r\n\r\n## 新しいホームページ\r\n\r\n2022 年 11 月下旬、文化祭も終わり落ち着き始めたころ、制作を開始しました。\r\n\r\nとにかく見た目を頑張った！\r\n\r\n![new website](./new-website-screenshot.webp)\r\n\r\n## デザイン\r\n\r\n- Figma というデザインソフトを使用しています。\r\n- 先輩の提案により、グラスモーフィズムを使ってみました〜\r\n- フォントはGoogle Fontより、`Orbitron`を使用。カッコイイ！\r\n\r\n# システム\r\n\r\n- Next.jsとTypeScriptで開発\r\n- 「お知らせ」と「ブログ」はマークダウンで記事を書けます！\r\n\r\n[コンテンツ管理に関する記事](/blog/)\r\n\r\n## その他\r\n\r\n- ソースコードは[こちら](https://github.com/tuatmcc/mcc-website)\r\n- 技術的な話はブログの方に書く予定です\r\n',
    html: '\n<p>MCC のホームページをリニューアルしたのでご報告</p>\n<h2 id="user-content-旧ホームページの状況">旧ホームページの状況</h2>\n<p>\n  <img src="./old-website-screenshot.webp" alt="old website">\n</p>\n<blockquote>\n  <p>古典的な WEB サイトを、現代のフロントエンド・フレームワークを駆使して書き直すコンセプトです。 古臭そうな見た目をしてる割に、がっつりレスポンシブ・SPA で動きます。</p>\n</blockquote>\n<p>とのこと。(中身は Nuxt2 でした)</p>\n<h2 id="user-content-新しいホームページ">新しいホームページ</h2>\n<p>2022 年 11 月下旬、文化祭も終わり落ち着き始めたころ、制作を開始しました。</p>\n<p>とにかく見た目を頑張った！</p>\n<p>\n  <img src="./new-website-screenshot.webp" alt="new website">\n</p>\n<h2 id="user-content-デザイン">デザイン</h2>\n<ul>\n  <li>Figma というデザインソフトを使用しています。</li>\n  <li>先輩の提案により、グラスモーフィズムを使ってみました〜</li>\n  <li>フォントはGoogle Fontより、<code>Orbitron</code>を使用。カッコイイ！</li>\n</ul>\n<h1 id="user-content-システム">システム</h1>\n<ul>\n  <li>Next.jsとTypeScriptで開発</li>\n  <li>「お知らせ」と「ブログ」はマークダウンで記事を書けます！</li>\n</ul>\n<p><a href="/blog/">コンテンツ管理に関する記事</a></p>\n<h2 id="user-content-その他">その他</h2>\n<ul>\n  <li>ソースコードは<a href="https://github.com/tuatmcc/mcc-website">こちら</a></li>\n  <li>技術的な話はブログの方に書く予定です</li>\n</ul>\n',
  },
  {
    title: 'MCCMMANCC2022を行いました',
    description: 'MCCMMANCC2022を行いました',
    date: '2022-12-17',
    tags: ['lt'],
    rootPath: 'content/news/2022-12-mccmmancc2022/index.md',
    postType: 'News',
    globPattern: 'content/news/**/index.md',
    markdown:
      '\n# MCCMMANCCとは\n\n> 名前が似ていてややこしい3大技術系MCC・MMA・NCCの交流イベントの季節が今年もやってきました！ 本イベントではLTイベントと体を使った楽しいレクリエーションの２つを通してサークル間の交流を深めようというイベントです。 普段交流する機会は少ないと思いますので是非この機会に交流の輪を広げましょう！\n\n今年は電通大のMMAが主催しました。\n\n',
    html: '\n<h1 id="user-content-mccmmanccとは">MCCMMANCCとは</h1>\n<blockquote>\n  <p>名前が似ていてややこしい3大技術系MCC・MMA・NCCの交流イベントの季節が今年もやってきました！ 本イベントではLTイベントと体を使った楽しいレクリエーションの２つを通してサークル間の交流を深めようというイベントです。 普段交流する機会は少ないと思いますので是非この機会に交流の輪を広げましょう！</p>\n</blockquote>\n<p>今年は電通大のMMAが主催しました。</p>\n',
  },
  {
    title: '部内勉強会を行いました',
    description: '部室の入室管理システムをnode.jsで作るをテーマに講習しました',
    img: 'first-blog-post.jpg',
    tags: ['dev'],
    date: '2022-03-16',
    rootPath: 'content/news/2022-03-nodejs-lesson/index.md',
    postType: 'News',
    globPattern: 'content/news/**/index.md',
    markdown:
      '\r\n## 部内勉強会を行いました\r\n\r\n部室の入室管理システムを node.js で作るをテーマに講習会を行いました。\r\n\r\n詳しくは[こちらのブログ記事](/blog/discord-bot-tutorial)をご覧ください。\r\n',
    html: '\n<h2 id="user-content-部内勉強会を行いました">部内勉強会を行いました</h2>\n<p>部室の入室管理システムを node.js で作るをテーマに講習会を行いました。</p>\n<p>詳しくは<a href="/blog/discord-bot-tutorial">こちらのブログ記事</a>をご覧ください。</p>\n',
  },
  {
    title: 'MCCMMANCC2021を行いました',
    description: 'Learning how to use @nuxt/content to create a blog',
    img: './mccmmancc2021.webp',
    tags: ['dev'],
    date: '2021-12',
    rootPath: 'content/news/2021-12-mmcmmancc2021/index.md',
    postType: 'News',
    globPattern: 'content/news/**/index.md',
    markdown:
      '\r\n## MCCMMANCC2021 を行いました\r\n\r\n農工大、電通大、明治大学のコンピューター系サークルが合同で LT を行う MCCMMANCC、今年度は農工大がホスト役となり行いました。\r\n農工大 MCC は多くの発表者とレクを行い、盛況のうち終了しました。\r\n',
    html: '\n<h2 id="user-content-mccmmancc2021-を行いました">MCCMMANCC2021 を行いました</h2>\n<p>\n  農工大、電通大、明治大学のコンピューター系サークルが合同で LT を行う MCCMMANCC、今年度は農工大がホスト役となり行いました。\r\n  農工大 MCC は多くの発表者とレクを行い、盛況のうち終了しました。\n</p>\n',
  },
];

export const allMember: PostTypeMember[] = [
  {
    title: 'おかず',
    date: '2023-03-27',
    rootPath: 'content/members/okazu/index.md',
    postType: 'Member',
    globPattern: 'content/members/**/index.md',
    markdown:
      '\n# Hi!\n\nプロフィールページの構成が未定です。\n現在は他の記事同様、マージダウンになっています。\n\ngithubでの編集を前提しているため、\nフォーム形式にできないのが辛いところです。\n\njson形式も悪くはないかもしれません。\nスキーマ等定義しておけば、ローカル環境でなら快適に\n編集できそう…\n\n何か案があれば教えてください。\n',
    html: '\n<h1 id="user-content-hi">Hi!</h1>\n<p>\n  プロフィールページの構成が未定です。\n  現在は他の記事同様、マージダウンになっています。\n</p>\n<p>\n  githubでの編集を前提しているため、\n  フォーム形式にできないのが辛いところです。\n</p>\n<p>\n  json形式も悪くはないかもしれません。\n  スキーマ等定義しておけば、ローカル環境でなら快適に\n  編集できそう…\n</p>\n<p>何か案があれば教えてください。</p>\n',
  },
];
export const allPosts = [...allBlog, ...allNews, ...allMember];
